<roblox version="4">
  <Item class="ReplicatedStorage" referent="0">
    <Properties>
      <string name="Name">ReplicatedStorage</string>
    </Properties>
    <Item class="BoolValue" referent="1">
      <Properties>
        <string name="Name">GameManagerReady</string>
        <bool name="Value">false</bool>
      </Properties>
    </Item>
    <Item class="Folder" referent="2">
      <Properties>
        <string name="Name">RemoteEvents</string>
      </Properties>
      <Item class="RemoteEvent" referent="3">
        <Properties>
          <string name="Name">CoinCollected</string>
        </Properties>
      </Item>
      <Item class="RemoteEvent" referent="4">
        <Properties>
          <string name="Name">CollectibleSpawned</string>
        </Properties>
      </Item>
      <Item class="RemoteEvent" referent="5">
        <Properties>
          <string name="Name">GameEnd</string>
        </Properties>
      </Item>
      <Item class="RemoteEvent" referent="6">
        <Properties>
          <string name="Name">GameRestart</string>
        </Properties>
      </Item>
      <Item class="RemoteEvent" referent="7">
        <Properties>
          <string name="Name">GameStart</string>
        </Properties>
      </Item>
      <Item class="RemoteEvent" referent="8">
        <Properties>
          <string name="Name">GameStateChanged</string>
        </Properties>
      </Item>
      <Item class="RemoteEvent" referent="9">
        <Properties>
          <string name="Name">ObstacleSpawned</string>
        </Properties>
      </Item>
      <Item class="RemoteEvent" referent="10">
        <Properties>
          <string name="Name">PlayerAction</string>
        </Properties>
      </Item>
      <Item class="RemoteEvent" referent="11">
        <Properties>
          <string name="Name">PlayerCollision</string>
        </Properties>
      </Item>
      <Item class="RemoteEvent" referent="12">
        <Properties>
          <string name="Name">PowerUpActivated</string>
        </Properties>
      </Item>
      <Item class="RemoteEvent" referent="13">
        <Properties>
          <string name="Name">PowerUpCollected</string>
        </Properties>
      </Item>
      <Item class="RemoteEvent" referent="14">
        <Properties>
          <string name="Name">PowerUpDeactivated</string>
        </Properties>
      </Item>
      <Item class="RemoteEvent" referent="15">
        <Properties>
          <string name="Name">ScoreUpdate</string>
        </Properties>
      </Item>
      <Item class="RemoteEvent" referent="16">
        <Properties>
          <string name="Name">SegmentSpawned</string>
        </Properties>
      </Item>
      <Item class="RemoteEvent" referent="17">
        <Properties>
          <string name="Name">UIUpdate</string>
        </Properties>
      </Item>
    </Item>
    <Item class="Folder" referent="18">
      <Properties>
        <string name="Name">RemoteFunctions</string>
      </Properties>
      <Item class="RemoteFunction" referent="19">
        <Properties>
          <string name="Name">GetLeaderboard</string>
        </Properties>
      </Item>
      <Item class="RemoteFunction" referent="20">
        <Properties>
          <string name="Name">GetServerStatus</string>
        </Properties>
      </Item>
      <Item class="RemoteFunction" referent="21">
        <Properties>
          <string name="Name">PurchaseItem</string>
        </Properties>
      </Item>
    </Item>
    <Item class="StringValue" referent="22">
      <Properties>
        <string name="Name">ServerPerformance</string>
        <string name="Value">Initializing...</string>
      </Properties>
    </Item>
    <Item class="BoolValue" referent="23">
      <Properties>
        <string name="Name">ServerReady</string>
        <bool name="Value">false</bool>
      </Properties>
    </Item>
    <Item class="BoolValue" referent="24">
      <Properties>
        <string name="Name">ServicesReady</string>
        <bool name="Value">false</bool>
      </Properties>
    </Item>
    <Item class="Folder" referent="25">
      <Properties>
        <string name="Name">Shared</string>
      </Properties>
      <Item class="ModuleScript" referent="26">
        <Properties>
          <string name="Name">GameConfig</string>
          <string name="Source"><![CDATA[-- GameConfig.lua - Shared configuration for the endless runner game
local GameConfig = {}

--[[
Type definitions for reference (Luau types when supported):
- PlayerConfig: { walkSpeed: number, jumpPower: number, jumpHeight: number, health: number, invulnerabilityTime: number }
- GameplayConfig: { baseSpeed: number, speedIncrement: number, maxSpeed: number, obstacleSpawnRate: number, collectibleSpawnRate: number, scoreMultiplier: number }
- WorldConfig: { platformWidth: number, platformLength: number, platformHeight: number, despawnDistance: number, spawnDistance: number }
--]]

-- Player settings
GameConfig.Player = {
    walkSpeed = 16,
    jumpPower = 50,
    jumpHeight = 20,
    health = 100,
    invulnerabilityTime = 2, -- seconds
}

-- Gameplay settings
GameConfig.Gameplay = {
    baseSpeed = 10,
    speedIncrement = 0.5,
    maxSpeed = 25,
    obstacleSpawnRate = 0.8, -- obstacles per second
    collectibleSpawnRate = 0.3, -- collectibles per second
    scoreMultiplier = 10,
}

-- World generation settings
GameConfig.World = {
    platformWidth = 20,
    platformLength = 50,
    platformHeight = 2,
    despawnDistance = 100, -- units behind player
    spawnDistance = 200, -- units ahead of player
}

-- Score values
GameConfig.Scores = {
    coin = 10,
    gem = 50,
    powerUp = 25,
    distanceMultiplier = 1, -- points per stud traveled
}

-- Power-up durations (in seconds)
GameConfig.PowerUps = {
    -- Legacy power-ups
    speedBoost = 5,
    shield = 8,
    magnet = 6,
    jumpBoost = 4,

    -- Subway Surfers style power-ups
    JETPACK = {
        name = "Jetpack",
        duration = 8,
        effect = "flight",
        color = Color3.fromRGB(255, 140, 0),
    },
    SUPER_SNEAKERS = {
        name = "Super Sneakers",
        duration = 10,
        effect = "highjump",
        color = Color3.fromRGB(0, 255, 0),
    },
    COIN_MAGNET = {
        name = "Coin Magnet",
        duration = 15,
        effect = "magnet",
        color = Color3.fromRGB(255, 0, 255),
    },
    MULTIPLIER = {
        name = "2x Multiplier",
        duration = 20,
        effect = "doublescore",
        color = Color3.fromRGB(255, 255, 0),
    },
}

-- Visual effects settings
GameConfig.Effects = {
    coinSpinSpeed = 2, -- rotations per second
    gemPulseSpeed = 1.5,
    particleLifetime = 2,
    cameraShakeIntensity = 0.5,
}

-- Audio settings
GameConfig.Audio = {
    masterVolume = 0.8,
    musicVolume = 0.6,
    sfxVolume = 0.7,
}

return GameConfig
]]></string>
        </Properties>
      </Item>
      <Item class="ModuleScript" referent="27">
        <Properties>
          <string name="Name">GameConstants</string>
          <string name="Source"><![CDATA[-- GameConstants.lua - Gemeinsame Konstanten für alle Module (circular dependency free)
--!strict

local GameConstants = {}

-- Spiel-Konfiguration (ohne komplexe Abhängigkeiten)
GameConstants.GAME = {
    FORWARD_SPEED = 25,
    LANE_WIDTH = 8,
    LANES = {
        LEFT = -1,
        CENTER = 0,
        RIGHT = 1,
    },
}

-- Lane-System Konstanten
GameConstants.LANE_POSITIONS = {
    [-1] = -8, -- Left lane X position
    [0] = 0, -- Center lane X position
    [1] = 8, -- Right lane X position
}

-- Bewegungs-Konstanten
GameConstants.MOVEMENT = {
    SPEED = 0.2,
    JUMP_HEIGHT = 20,
    JUMP_DURATION = 0.8,
    SLIDE_DURATION = 1.0,
}

-- Einfache Lane-Position Berechnung (ohne externe Abhängigkeiten)
function GameConstants.GetLanePosition(lane: number): number
    return GameConstants.LANE_POSITIONS[lane] or 0
end

-- Power-Up Types (einfache Enums)
GameConstants.POWER_UP_TYPES = {
    JETPACK = "JETPACK",
    COIN_MAGNET = "COIN_MAGNET",
    SUPER_SNEAKERS = "SUPER_SNEAKERS",
    SCORE_MULTIPLIER = "SCORE_MULTIPLIER",
}

-- Obstacle Types (einfache Enums)
GameConstants.OBSTACLE_TYPES = {
    BARRIER = "BARRIER",
    TRAIN = "TRAIN",
    TUNNEL_ENTRANCE = "TUNNEL_ENTRANCE",
}

-- Collectible Types (einfache Enums)
GameConstants.COLLECTIBLE_TYPES = {
    COIN = "COIN",
    LETTER = "LETTER",
    KEY = "KEY",
}

return GameConstants
]]></string>
        </Properties>
      </Item>
      <Item class="ModuleScript" referent="28">
        <Properties>
          <string name="Name">GameState</string>
          <string name="Source"><![CDATA[-- GameState.lua - Shared game state management
local GameState = {}

-- Game states enumeration
GameState.States = {
    MENU = "Menu",
    PLAYING = "Playing",
    PAUSED = "Paused",
    GAME_OVER = "GameOver",
    LOADING = "Loading",
}

-- Player data structure
GameState.DefaultPlayerData = {
    score = 0,
    highScore = 0,
    coins = 0,
    gems = 0,
    distance = 0,
    powerUpsCollected = 0,
    gamesPlayed = 0,
    totalPlayTime = 0,
}

-- Current game session data
GameState.SessionData = {
    currentScore = 0,
    currentDistance = 0,
    currentSpeed = 0,
    powerUpsActive = {},
    obstaclesHit = 0,
    collectiblesGathered = 0,
    startTime = 0,
    endTime = 0,
}

-- Power-up types
GameState.PowerUpTypes = {
    SPEED_BOOST = "SpeedBoost",
    SHIELD = "Shield",
    MAGNET = "Magnet",
    JUMP_BOOST = "JumpBoost",
}

-- Collectible types
GameState.CollectibleTypes = {
    COIN = "Coin",
    GEM = "Gem",
    POWER_UP = "PowerUp",
}

-- Obstacle types
GameState.ObstacleTypes = {
    BARRIER = "Barrier",
    SPIKE = "Spike",
    MOVING_PLATFORM = "MovingPlatform",
    GAP = "Gap",
}

-- Reset session data
function GameState.ResetSession()
    GameState.SessionData = {
        currentScore = 0,
        currentDistance = 0,
        currentSpeed = 0,
        powerUpsActive = {},
        obstaclesHit = 0,
        collectiblesGathered = 0,
        startTime = tick(),
        endTime = 0,
    }
end

-- Check if power-up is active
function GameState.IsPowerUpActive(powerUpType)
    return GameState.SessionData.powerUpsActive[powerUpType] ~= nil
        and GameState.SessionData.powerUpsActive[powerUpType] > tick()
end

-- Activate power-up
function GameState.ActivatePowerUp(powerUpType, duration)
    GameState.SessionData.powerUpsActive[powerUpType] = tick() + duration
end

-- Clean up expired power-ups
function GameState.CleanupExpiredPowerUps()
    local currentTime = tick()
    for powerUpType, expireTime in pairs(GameState.SessionData.powerUpsActive) do
        if expireTime <= currentTime then
            GameState.SessionData.powerUpsActive[powerUpType] = nil
        end
    end
end

-- Calculate final score with bonuses
function GameState.CalculateFinalScore()
    local baseScore = GameState.SessionData.currentScore
    local distanceBonus = math.floor(GameState.SessionData.currentDistance / 10)
    local collectibleBonus = GameState.SessionData.collectiblesGathered * 5
    local survivalBonus = math.max(0, 100 - GameState.SessionData.obstaclesHit * 10)

    return baseScore + distanceBonus + collectibleBonus + survivalBonus
end

return GameState
]]></string>
        </Properties>
      </Item>
      <Item class="ModuleScript" referent="29">
        <Properties>
          <string name="Name">ObjectPool</string>
          <string name="Source"><![CDATA[--!strict
-- ObjectPool.lua - High-performance object pooling system for Subway Surfers
local ObjectPool = {}

-- Type definitions
export type PoolConfig = {
    initialSize: number,
    maxSize: number,
    createFunction: () -> Instance,
    resetFunction: (Instance) -> (),
    validateFunction: (Instance) -> boolean,
}

export type Pool = {
    available: { Instance },
    inUse: { Instance },
    config: PoolConfig,
    totalCreated: number,
}

-- Create a new object pool
function ObjectPool.new(config: PoolConfig): Pool
    assert(config, "Pool config is required")
    assert(config.createFunction, "createFunction is required")
    assert(config.resetFunction, "resetFunction is required")

    local pool: Pool = {
        available = {},
        inUse = {},
        config = config,
        totalCreated = 0,
    }

    -- Pre-populate pool with initial objects
    for _ = 1, config.initialSize do
        local obj = config.createFunction()
        if obj then
            obj.Parent = nil -- Keep objects hidden initially
            table.insert(pool.available, obj)
            pool.totalCreated += 1
        end
    end

    return pool
end

-- Get an object from the pool
function ObjectPool.get(pool: Pool): Instance?
    local obj = table.remove(pool.available)

    -- Create new object if pool is empty and under max size
    if not obj and pool.totalCreated < pool.config.maxSize then
        obj = pool.config.createFunction()
        if obj then
            pool.totalCreated += 1
        end
    end

    if obj then
        -- Validate object is still usable
        if pool.config.validateFunction and not pool.config.validateFunction(obj) then
            obj:Destroy()
            pool.totalCreated -= 1
            return ObjectPool.get(pool) -- Try again recursively
        end

        table.insert(pool.inUse, obj)
        pool.config.resetFunction(obj)
    end

    return obj
end

-- Return an object to the pool
function ObjectPool.returnToPool(pool: Pool, obj: Instance)
    if not obj then
        return
    end

    -- Remove from inUse list
    for i, usedObj in ipairs(pool.inUse) do
        if usedObj == obj then
            table.remove(pool.inUse, i)
            break
        end
    end

    -- Hide object and add to available pool
    obj.Parent = nil
    -- Move BasePart objects far away
    if obj:IsA("BasePart") then
        obj.CFrame = CFrame.new(0, -1000, 0)
    end
    table.insert(pool.available, obj)
end

-- Clean up expired or invalid objects
function ObjectPool.cleanup(pool: Pool)
    -- Clean available objects
    for i = #pool.available, 1, -1 do
        local obj = pool.available[i]
        if not obj or not obj.Parent then
            table.remove(pool.available, i)
            if obj then
                obj:Destroy()
            end
            pool.totalCreated -= 1
        end
    end

    -- Clean in-use objects that are no longer valid
    for i = #pool.inUse, 1, -1 do
        local obj = pool.inUse[i]
        if not obj or not obj.Parent then
            table.remove(pool.inUse, i)
            if obj then
                obj:Destroy()
            end
            pool.totalCreated -= 1
        end
    end
end

-- Get pool statistics
function ObjectPool.getStats(pool: Pool)
    return {
        available = #pool.available,
        inUse = #pool.inUse,
        totalCreated = pool.totalCreated,
        maxSize = pool.config.maxSize,
    }
end

-- Destroy all objects in pool
function ObjectPool.destroy(pool: Pool)
    -- Destroy available objects
    for _, obj in ipairs(pool.available) do
        if obj then
            obj:Destroy()
        end
    end

    -- Destroy in-use objects
    for _, obj in ipairs(pool.inUse) do
        if obj then
            obj:Destroy()
        end
    end

    -- Clear arrays
    table.clear(pool.available)
    table.clear(pool.inUse)
    pool.totalCreated = 0
end

return ObjectPool
]]></string>
        </Properties>
      </Item>
      <Item class="ModuleScript" referent="30">
        <Properties>
          <string name="Name">SegmentSpawner</string>
          <string name="Source"><![CDATA[--!strict
-- SegmentSpawner.lua - Unified Track Segment Generation (Integrated with WorldBuilder)
-- Arbeitet zusammen mit DynamicWorldGenerator für kohärente Welt-Erstellung

local SegmentSpawner = {}

local ReplicatedStorage = game:GetService("ReplicatedStorage")
local RunService = game:GetService("RunService")

-- Enhanced module loading mit Fehlerbehandlung
local function loadModuleSafe(path: string, fallback: any?): any?
    local success, module = pcall(function()
        return require(ReplicatedStorage:WaitForChild("Shared"):WaitForChild(path))
    end)

    if success and module then
        return module
    else
        warn("[SegmentSpawner] Failed to load module:", path)
        return fallback or {}
    end
end

-- Import shared modules mit safe loading
local GameConfig = loadModuleSafe("GameConfig") :: any
local SubwaySurfersGameplay = loadModuleSafe("SubwaySurfersGameplay") :: any

-- Enhanced Type Definitions
export type SegmentData = {
    id: string,
    position: Vector3,
    length: number,
    obstacles: { any },
    collectibles: { any },
    pattern: string,
    difficulty: number,
    isActive: boolean,
    spawnTime: number,
}

-- Enhanced Constants
local SEGMENT_LENGTH = 50
local SEGMENTS_AHEAD = 3 -- Reduziert um Konflikte zu vermeiden
local SPAWN_DISTANCE = 150 -- Reduziert für bessere Performance
local DESPAWN_DISTANCE = -50

-- State Management
local activeSegments: { SegmentData } = {}
local segmentCounter = 0
local isInitialized = false
local integrationMode = false -- Kooperation mit DynamicWorldGenerator

-- Enhanced Segment Templates mit besserer Balance
local segmentTemplates = {
    {
        name = "BasicRun",
        length = SEGMENT_LENGTH,
        difficulty = 1,
        obstacles = { "BARRIER" },
        collectibles = { "COIN_LINE" },
        spawnChance = 0.5,
    },
    {
        name = "CoinCollection",
        length = SEGMENT_LENGTH,
        difficulty = 1,
        obstacles = {},
        collectibles = { "COIN_LINE", "COIN" },
        spawnChance = 0.3,
    },
    {
        name = "PowerUpRun",
        length = SEGMENT_LENGTH,
        difficulty = 2,
        obstacles = { "SIGN_POST" },
        collectibles = { "COIN", "POWER_UP" },
        spawnChance = 0.15,
        hasPowerUp = true,
    },
}

-- Initialize the segment spawner
function SegmentSpawner:Initialize()
    if isInitialized then
        print("[SegmentSpawner] ⚠️ Already initialized, skipping duplicate initialization")
        return
    end

    print("[SegmentSpawner] Initializing segment spawning system...")

    -- Create initial segments
    self:SpawnInitialSegments()

    -- Connect to update loop
    RunService.Heartbeat:Connect(function()
        self:Update()
    end)

    isInitialized = true
    print("[SegmentSpawner] ✅ Segment spawning system initialized successfully")
end

-- Spawn initial segments
function SegmentSpawner:SpawnInitialSegments()
    print("[SegmentSpawner] Creating initial track segments...")

    -- Create starting platform
    self:CreateStartingPlatform()

    -- Create initial segments ahead
    for i = 1, SEGMENTS_AHEAD do
        local zPosition = i * SEGMENT_LENGTH
        self:CreateSegment(zPosition, "BasicRun", 1)
    end

    print("[SegmentSpawner] Initial segments created")
end

-- Create starting platform (safe spawn area)
function SegmentSpawner:CreateStartingPlatform()
    local startPlatform = Instance.new("Part")
    startPlatform.Name = "StartingPlatform"
    startPlatform.Size = Vector3.new(20, 2, 30)
    startPlatform.Position = Vector3.new(0, 0, -15)
    startPlatform.Material = Enum.Material.Concrete
    startPlatform.BrickColor = BrickColor.new("Medium stone grey")
    startPlatform.Anchored = true
    startPlatform.Parent = workspace

    -- Add lane markers
    for lane = -1, 1 do
        local marker = Instance.new("Part")
        marker.Name = "LaneMarker_" .. lane
        marker.Size = Vector3.new(0.2, 0.1, 30)
        marker.Position = Vector3.new(SubwaySurfersGameplay.GetLanePosition(lane), 1.1, -15)
        marker.Material = Enum.Material.Neon
        marker.BrickColor = BrickColor.new("Bright yellow")
        marker.Anchored = true
        marker.Parent = startPlatform
    end

    print("[SegmentSpawner] Starting platform created")
end

-- Create a new segment
function SegmentSpawner:CreateSegment(zPosition: number, templateName: string?, difficulty: number?)
    segmentCounter = segmentCounter + 1

    -- Select template
    local template = self:SelectTemplate(templateName, difficulty or 1)
    if not template then
        warn("[SegmentSpawner] Failed to find segment template:", templateName)
        return
    end

    -- Create segment data
    local segmentData: SegmentData = {
        id = "Segment_" .. segmentCounter,
        position = Vector3.new(0, 0, zPosition),
        length = template.length,
        obstacles = {},
        collectibles = {},
        pattern = template.name,
        difficulty = template.difficulty,
        isActive = true,
        spawnTime = tick(),
    }

    -- Create base platform
    local _platform = self:CreateBasePlatform(segmentData)

    -- Add obstacles
    self:SpawnObstacles(segmentData, template.obstacles)

    -- Add collectibles
    self:SpawnCollectibles(segmentData, template.collectibles, template.hasPowerUp)

    -- Add to active segments
    table.insert(activeSegments, segmentData)

    print("[SegmentSpawner] Created segment:", segmentData.id, "at Z:", zPosition)
    return segmentData
end

-- Select appropriate template based on difficulty and randomness
function SegmentSpawner:SelectTemplate(templateName: string?, difficulty: number): any?
    if templateName then
        for _, template in ipairs(segmentTemplates) do
            if template.name == templateName then
                return template
            end
        end
    end

    -- Random selection based on spawn chance and difficulty
    local availableTemplates = {}
    for _, template in ipairs(segmentTemplates) do
        if template.difficulty <= difficulty and math.random() < template.spawnChance then
            table.insert(availableTemplates, template)
        end
    end

    if #availableTemplates > 0 then
        return availableTemplates[math.random(1, #availableTemplates)]
    end

    -- Fallback to basic run
    return segmentTemplates[1]
end

-- Create base platform for segment
function SegmentSpawner:CreateBasePlatform(segmentData: SegmentData): Part
    local platform = Instance.new("Part")
    platform.Name = segmentData.id .. "_Platform"
    platform.Size = Vector3.new(GameConfig.World.platformWidth, GameConfig.World.platformHeight, segmentData.length)
    platform.Position = segmentData.position
    platform.Material = Enum.Material.Concrete
    platform.BrickColor = BrickColor.new("Medium stone grey")
    platform.Anchored = true
    platform.Parent = workspace

    -- Add lane dividers
    for lane = -1, 1 do
        if lane ~= 0 then -- Don't put divider in center
            local divider = Instance.new("Part")
            divider.Name = "LaneDivider_" .. lane
            divider.Size = Vector3.new(0.1, 0.2, segmentData.length)
            divider.Position = Vector3.new(
                SubwaySurfersGameplay.GetLanePosition(lane) + (lane < 0 and 4 or -4),
                segmentData.position.Y + 1.1,
                segmentData.position.Z
            )
            divider.Material = Enum.Material.Neon
            divider.BrickColor = BrickColor.new("Bright yellow")
            divider.Anchored = true
            divider.Parent = platform
        end
    end

    return platform
end

-- Spawn obstacles in segment
function SegmentSpawner:SpawnObstacles(segmentData: SegmentData, obstacleTypes: { string })
    local obstacleCount = math.random(1, 3)
    local usedLanes = {}

    for _ = 1, obstacleCount do
        local obstacleType = obstacleTypes[math.random(1, #obstacleTypes)]
        local availableLanes = {}

        -- Find available lanes
        for lane = -1, 1 do
            if not usedLanes[lane] then
                table.insert(availableLanes, lane)
            end
        end

        if #availableLanes == 0 then
            break -- No more lanes available
        end

        local lane = availableLanes[math.random(1, #availableLanes)]
        usedLanes[lane] = true

        local obstacle = self:CreateObstacle(obstacleType, lane, segmentData)
        if obstacle then
            table.insert(segmentData.obstacles, obstacle)
        end
    end
end

-- Create individual obstacle
function SegmentSpawner:CreateObstacle(obstacleType: string, lane: number, segmentData: SegmentData): Part?
    local obstacleData = SubwaySurfersGameplay.ObstacleTypes[obstacleType]
    if not obstacleData then
        warn("[SegmentSpawner] Unknown obstacle type:", obstacleType)
        return nil
    end

    local obstacle = Instance.new("Part")
    obstacle.Name = obstacleType .. "_" .. segmentData.id
    obstacle.Size = Vector3.new(obstacleData.width, obstacleData.height, 2)
    obstacle.Position = Vector3.new(
        SubwaySurfersGameplay.GetLanePosition(lane),
        segmentData.position.Y + obstacleData.height / 2 + 1,
        segmentData.position.Z + math.random(-segmentData.length / 3, segmentData.length / 3)
    )
    obstacle.Material = Enum.Material.Metal
    obstacle.BrickColor = BrickColor.new("Really red")
    obstacle.Anchored = true
    obstacle.Parent = workspace

    -- Add obstacle type data
    local stringValue = Instance.new("StringValue")
    stringValue.Name = "ObstacleType"
    stringValue.Value = obstacleType
    stringValue.Parent = obstacle

    return obstacle
end

-- Spawn collectibles in segment
function SegmentSpawner:SpawnCollectibles(segmentData: SegmentData, collectibleTypes: { string }, hasPowerUp: boolean?)
    -- Spawn regular collectibles
    for _, collectibleType in ipairs(collectibleTypes) do
        if collectibleType == "COIN_LINE" then
            self:CreateCoinLine(segmentData)
        elseif collectibleType == "COIN" then
            self:CreateScatteredCoins(segmentData, math.random(3, 8))
        elseif collectibleType == "GEM" then
            self:CreateGem(segmentData)
        elseif collectibleType == "MYSTERY_BOX" then
            self:CreateMysteryBox(segmentData)
        end
    end

    -- Spawn power-up if specified
    if hasPowerUp then
        self:CreatePowerUp(segmentData)
    end
end

-- Create coin line (like Subway Surfers)
function SegmentSpawner:CreateCoinLine(segmentData: SegmentData)
    local lane = math.random(-1, 1)
    local coinCount = 8
    local spacing = segmentData.length / (coinCount + 1)

    for i = 1, coinCount do
        local coin = self:CreateCoin(
            Vector3.new(
                SubwaySurfersGameplay.GetLanePosition(lane),
                segmentData.position.Y + 3,
                segmentData.position.Z - segmentData.length / 2 + (i * spacing)
            )
        )
        if coin then
            table.insert(segmentData.collectibles, coin)
        end
    end
end

-- Create scattered coins
function SegmentSpawner:CreateScatteredCoins(segmentData: SegmentData, count: number)
    for _ = 1, count do
        local lane = math.random(-1, 1)
        local coin = self:CreateCoin(
            Vector3.new(
                SubwaySurfersGameplay.GetLanePosition(lane),
                segmentData.position.Y + 3,
                segmentData.position.Z + math.random(-segmentData.length / 2, segmentData.length / 2)
            )
        )
        if coin then
            table.insert(segmentData.collectibles, coin)
        end
    end
end

-- Create individual coin
function SegmentSpawner:CreateCoin(position: Vector3): Part?
    local coin = Instance.new("Part")
    coin.Name = "Coin"
    coin.Shape = Enum.PartType.Cylinder
    coin.Size = Vector3.new(0.2, 2, 2)
    coin.Position = position
    coin.Material = Enum.Material.Neon
    coin.BrickColor = BrickColor.new("Bright yellow")
    coin.Anchored = true
    coin.CanCollide = false
    coin.Parent = workspace

    -- Add rotation animation
    local rotateConnection
    rotateConnection = RunService.Heartbeat:Connect(function(deltaTime)
        if coin.Parent then
            coin.CFrame = coin.CFrame * CFrame.Angles(0, 0, math.rad(360 * deltaTime * 2))
        else
            rotateConnection:Disconnect()
        end
    end)

    return coin
end

-- Create power-up
function SegmentSpawner:CreatePowerUp(segmentData: SegmentData)
    local lane = math.random(-1, 1)
    local powerUp = Instance.new("Part")
    powerUp.Name = "PowerUp"
    powerUp.Shape = Enum.PartType.Block
    powerUp.Size = Vector3.new(2, 2, 2)
    powerUp.Position =
        Vector3.new(SubwaySurfersGameplay.GetLanePosition(lane), segmentData.position.Y + 3, segmentData.position.Z)
    powerUp.Material = Enum.Material.ForceField
    powerUp.BrickColor = BrickColor.new("Bright blue")
    powerUp.Anchored = true
    powerUp.CanCollide = false
    powerUp.Parent = workspace

    -- Add pulsing effect
    local pulseConnection
    pulseConnection = RunService.Heartbeat:Connect(function()
        if powerUp.Parent then
            local time = tick()
            local scale = 1 + 0.2 * math.sin(time * 4)
            powerUp.Size = Vector3.new(2 * scale, 2 * scale, 2 * scale)
        else
            pulseConnection:Disconnect()
        end
    end)

    table.insert(segmentData.collectibles, powerUp)
end

-- Create gem
function SegmentSpawner:CreateGem(segmentData: SegmentData)
    local lane = math.random(-1, 1)
    local gem = Instance.new("Part")
    gem.Name = "Gem"
    gem.Shape = Enum.PartType.Ball
    gem.Size = Vector3.new(1.5, 1.5, 1.5)
    gem.Position = Vector3.new(
        SubwaySurfersGameplay.GetLanePosition(lane),
        segmentData.position.Y + 3,
        segmentData.position.Z + math.random(-segmentData.length / 3, segmentData.length / 3)
    )
    gem.Material = Enum.Material.Neon
    gem.BrickColor = BrickColor.new("Bright green")
    gem.Anchored = true
    gem.CanCollide = false
    gem.Parent = workspace

    table.insert(segmentData.collectibles, gem)
end

-- Create mystery box
function SegmentSpawner:CreateMysteryBox(segmentData: SegmentData)
    local lane = math.random(-1, 1)
    local box = Instance.new("Part")
    box.Name = "MysteryBox"
    box.Shape = Enum.PartType.Block
    box.Size = Vector3.new(2, 2, 2)
    box.Position =
        Vector3.new(SubwaySurfersGameplay.GetLanePosition(lane), segmentData.position.Y + 3, segmentData.position.Z)
    box.Material = Enum.Material.Neon
    box.BrickColor = BrickColor.new("Bright violet")
    box.Anchored = true
    box.CanCollide = false
    box.Parent = workspace

    table.insert(segmentData.collectibles, box)
end

-- Update loop - manage segment spawning and cleanup
function SegmentSpawner:Update()
    -- Get player position (safe player access)
    local Players = game:GetService("Players")
    local player = Players:GetPlayers()[1]
    if not player or not player.Character or not player.Character:FindFirstChild("HumanoidRootPart") then
        return
    end

    local playerZ = (player.Character:FindFirstChild("HumanoidRootPart") :: BasePart).Position.Z

    -- Check if we need to spawn new segments ahead
    local furthestZ = self:GetFurthestSegmentZ()
    if playerZ + SPAWN_DISTANCE > furthestZ then
        local newZ = furthestZ + SEGMENT_LENGTH
        local difficulty = math.min(5, math.floor(playerZ / 500) + 1)
        self:CreateSegment(newZ, nil, difficulty)
    end

    -- Clean up old segments behind player
    self:CleanupOldSegments(playerZ)
end

-- Get Z position of furthest segment
function SegmentSpawner:GetFurthestSegmentZ(): number
    local furthestZ = 0
    for _, segment in ipairs(activeSegments) do
        local segmentEndZ = segment.position.Z + segment.length / 2
        if segmentEndZ > furthestZ then
            furthestZ = segmentEndZ
        end
    end
    return furthestZ
end

-- Clean up segments that are behind the player
function SegmentSpawner:CleanupOldSegments(playerZ: number)
    local segmentsToRemove = {}

    for i, segment in ipairs(activeSegments) do
        local segmentEndZ = segment.position.Z + segment.length / 2
        if segmentEndZ < playerZ + DESPAWN_DISTANCE then
            table.insert(segmentsToRemove, i)

            -- Clean up segment parts
            self:DestroySegment(segment)
        end
    end

    -- Remove from active list (reverse order to maintain indices)
    for i = #segmentsToRemove, 1, -1 do
        table.remove(activeSegments, segmentsToRemove[i])
    end

    if #segmentsToRemove > 0 then
        print("[SegmentSpawner] Cleaned up", #segmentsToRemove, "old segments")
    end
end

-- Destroy segment and all its parts
function SegmentSpawner:DestroySegment(segment: SegmentData)
    -- Find and destroy platform
    local platform = workspace:FindFirstChild(segment.id .. "_Platform")
    if platform then
        platform:Destroy()
    end

    -- Destroy obstacles
    for _, obstacle in ipairs(segment.obstacles) do
        if obstacle and obstacle.Parent then
            obstacle:Destroy()
        end
    end

    -- Destroy collectibles
    for _, collectible in ipairs(segment.collectibles) do
        if collectible and collectible.Parent then
            collectible:Destroy()
        end
    end
end

-- Get active segments (for debugging)
function SegmentSpawner:GetActiveSegments(): { SegmentData }
    return activeSegments
end

-- Reset spawner (for game restart)
function SegmentSpawner:Reset()
    print("[SegmentSpawner] Resetting segment spawner...")

    -- Clean up all active segments
    for _, segment in ipairs(activeSegments) do
        self:DestroySegment(segment)
    end

    activeSegments = {}
    segmentCounter = 0

    -- Respawn initial segments
    self:SpawnInitialSegments()

    print("[SegmentSpawner] Segment spawner reset complete")
end

return SegmentSpawner
]]></string>
        </Properties>
      </Item>
      <Item class="ModuleScript" referent="31">
        <Properties>
          <string name="Name">SubwaySurfersGameplay</string>
          <string name="Source"><![CDATA[-- SubwaySurfersGameplay.lua - Subway Surfers inspired gameplay mechanics
local SubwaySurfersGameplay = {}

-- Track/Lane system (like Subway Surfers' 3-lane system)
SubwaySurfersGameplay.Lanes = {
    LEFT = -1,
    CENTER = 0,
    RIGHT = 1,
}

SubwaySurfersGameplay.LanePositions = {
    [-1] = -8, -- Left lane X position
    [0] = 0, -- Center lane X position
    [1] = 8, -- Right lane X position
}

-- Player movement states
SubwaySurfersGameplay.MovementStates = {
    RUNNING = "Running",
    JUMPING = "Jumping",
    ROLLING = "Rolling",
    SLIDING = "Sliding",
    FALLING = "Falling",
}

-- Power-ups (Subway Surfers style)
SubwaySurfersGameplay.PowerUps = {
    JETPACK = {
        name = "Jetpack",
        duration = 8,
        effect = "flight",
        color = Color3.fromRGB(255, 140, 0),
    },
    SUPER_SNEAKERS = {
        name = "Super Sneakers",
        duration = 10,
        effect = "highjump",
        color = Color3.fromRGB(0, 255, 0),
    },
    COIN_MAGNET = {
        name = "Coin Magnet",
        duration = 15,
        effect = "magnet",
        color = Color3.fromRGB(255, 0, 255),
    },
    MULTIPLIER = {
        name = "2x Multiplier",
        duration = 20,
        effect = "doublescore",
        color = Color3.fromRGB(255, 255, 0),
    },
}

-- Obstacle types (Subway Surfers inspired)
SubwaySurfersGameplay.ObstacleTypes = {
    TRAIN = {
        name = "Train",
        height = 6,
        width = 4,
        canJumpOver = false,
        canSlideUnder = false,
        canDodge = true,
    },
    BARRIER = {
        name = "Barrier",
        height = 3,
        width = 2,
        canJumpOver = true,
        canSlideUnder = false,
        canDodge = true,
    },
    TUNNEL_ENTRANCE = {
        name = "Tunnel",
        height = 2,
        width = 8,
        canJumpOver = false,
        canSlideUnder = true,
        canDodge = false,
    },
    SIGN_POST = {
        name = "Sign",
        height = 4,
        width = 1,
        canJumpOver = true,
        canSlideUnder = true,
        canDodge = true,
    },
}

-- Collectible types (Subway Surfers style)
SubwaySurfersGameplay.CollectibleTypes = {
    COIN = {
        name = "Coin",
        value = 1,
        scoreValue = 10,
        color = Color3.fromRGB(255, 215, 0),
        size = Vector3.new(1, 1, 0.2),
        rotationSpeed = 2,
    },
    COIN_LINE = {
        name = "CoinLine",
        value = 5,
        scoreValue = 50,
        color = Color3.fromRGB(255, 215, 0),
        size = Vector3.new(1, 1, 0.2),
        rotationSpeed = 2,
        spacing = 3,
    },
    KEY = {
        name = "Key",
        value = 1,
        scoreValue = 0,
        color = Color3.fromRGB(0, 191, 255),
        size = Vector3.new(1.5, 2, 0.3),
        rotationSpeed = 1.5,
        special = true,
    },
    MYSTERY_BOX = {
        name = "MysteryBox",
        value = 1,
        scoreValue = 100,
        color = Color3.fromRGB(138, 43, 226),
        size = Vector3.new(2, 2, 2),
        rotationSpeed = 0.8,
        special = true,
    },
}

-- Mission system (like Subway Surfers daily missions)
SubwaySurfersGameplay.Missions = {
    {
        id = "collect_coins",
        name = "Coin Collector",
        description = "Collect 100 coins in a single run",
        target = 100,
        reward = 500,
        type = "collect",
    },
    {
        id = "jump_obstacles",
        name = "Leap Frog",
        description = "Jump over 20 obstacles",
        target = 20,
        reward = 300,
        type = "action",
    },
    {
        id = "run_distance",
        name = "Marathon Runner",
        description = "Run 2000 meters",
        target = 2000,
        reward = 750,
        type = "distance",
    },
    {
        id = "use_powerups",
        name = "Power Player",
        description = "Use 5 power-ups in one run",
        target = 5,
        reward = 400,
        type = "powerup",
    },
}

-- Character abilities (Subway Surfers movement)
SubwaySurfersGameplay.Abilities = {
    DOUBLE_TAP_ROLL = {
        name = "Roll",
        cooldown = 1,
        description = "Roll under low obstacles",
    },
    SWIPE_DODGE = {
        name = "Lane Switch",
        cooldown = 0.3,
        description = "Quickly move between lanes",
    },
    HOVER_BOARD = {
        name = "Hoverboard",
        duration = 30,
        description = "Temporary invincibility and speed boost",
        consumable = true,
    },
}

-- World generation patterns (Subway Surfers style track segments)
SubwaySurfersGameplay.TrackPatterns = {
    {
        name = "CoinTunnel",
        length = 50,
        difficulty = 1,
        coins = "line",
        obstacles = { "TUNNEL_ENTRANCE" },
    },
    {
        name = "TrainDodge",
        length = 30,
        difficulty = 3,
        coins = "scattered",
        obstacles = { "TRAIN", "BARRIER" },
    },
    {
        name = "PowerUpRun",
        length = 40,
        difficulty = 2,
        coins = "bonus",
        powerup = true,
        obstacles = { "SIGN_POST" },
    },
    {
        name = "Challenge",
        length = 60,
        difficulty = 4,
        coins = "high_reward",
        obstacles = { "TRAIN", "BARRIER", "TUNNEL_ENTRANCE" },
    },
}

-- Speed progression (like Subway Surfers increasing difficulty)
SubwaySurfersGameplay.SpeedProgression = {
    { distance = 0, speed = 12, spawnRate = 0.5 },
    { distance = 500, speed = 15, spawnRate = 0.7 },
    { distance = 1000, speed = 18, spawnRate = 0.9 },
    { distance = 2000, speed = 22, spawnRate = 1.2 },
    { distance = 3500, speed = 25, spawnRate = 1.5 },
    { distance = 5000, speed = 28, spawnRate = 1.8 },
}

-- Get current lane position for player
function SubwaySurfersGameplay.GetLanePosition(lane)
    return SubwaySurfersGameplay.LanePositions[lane] or 0
end

-- Check if obstacle can be avoided by specific action
function SubwaySurfersGameplay.CanAvoidObstacle(obstacleType, action)
    local obstacle = SubwaySurfersGameplay.ObstacleTypes[obstacleType]
    if not obstacle then
        return false
    end

    if action == "jump" then
        return obstacle.canJumpOver
    elseif action == "slide" then
        return obstacle.canSlideUnder
    elseif action == "dodge" then
        return obstacle.canDodge
    end

    return false
end

-- Get speed settings for current distance
function SubwaySurfersGameplay.GetSpeedForDistance(distance)
    local settings = SubwaySurfersGameplay.SpeedProgression[1]

    for _, speedSetting in ipairs(SubwaySurfersGameplay.SpeedProgression) do
        if distance >= speedSetting.distance then
            settings = speedSetting
        else
            break
        end
    end

    return settings
end

-- Calculate score multiplier based on current state
function SubwaySurfersGameplay.CalculateScoreMultiplier(powerUps: any?, distance: any): number
    local multiplier: number = 1
    local distanceNum: number = tonumber(distance) or 0

    -- Distance bonus
    multiplier = multiplier + math.floor(distanceNum / 1000) * 0.1

    -- Power-up multiplier
    if powerUps and powerUps.MULTIPLIER then
        multiplier = multiplier * 2
    end

    return math.min(multiplier, 5) -- Cap at 5x
end

return SubwaySurfersGameplay
]]></string>
        </Properties>
      </Item>
      <Item class="ModuleScript" referent="32">
        <Properties>
          <string name="Name">TypeDefinitions</string>
          <string name="Source"><![CDATA[-- TypeDefinitions.lua - Zentrale Type-Definitionen für Type-Safety
--!strict

-- Player State Type
export type PlayerState = {
    lane: number,
    isJumping: boolean,
    isSliding: boolean,
    speed: number,
    distance: number,
    isGameActive: boolean,
}

-- Connection Types für bessere nil-handling
export type OptionalConnection = RBXScriptConnection?
export type OptionalTween = Tween?

-- Enhanced Player Controller Interface
export type IEnhancedPlayerController = {
    player: Player,
    character: Model?,
    humanoid: Humanoid?,
    rootPart: BasePart?,
    state: PlayerState,
    forwardMovementConnection: OptionalConnection,
    inputConnection: OptionalConnection,
    movementTween: OptionalTween,
}

-- Game Configuration Type
export type GameConfig = {
    MOVEMENT_SPEED: number,
    FORWARD_SPEED: number,
    JUMP_HEIGHT: number,
    JUMP_DURATION: number,
    SLIDE_DURATION: number,
    LANE_WIDTH: number,
}

-- Camera Controller Type
export type ICameraController = {
    Camera: Camera,
    Player: Player?,
    RootPart: BasePart?,
    CameraConnection: OptionalConnection,
    OriginalCFrame: CFrame?,
    IsGameCameraActive: boolean,
}

-- Game Session Type
export type GameSession = {
    startTime: number,
    initiatingPlayer: Player,
}

-- Game Coordinator Status
export type GameCoordinatorStatus = {
    initialized: boolean,
    activeSession: boolean,
    worldGeneratorActive: boolean,
    gameLoopState: string,
    playerCount: number,
}

return {}
]]></string>
        </Properties>
      </Item>
    </Item>
  </Item>
  <Item class="ServerScriptService" referent="33">
    <Properties>
      <string name="Name">ServerScriptService</string>
    </Properties>
    <Item class="ModuleScript" referent="34">
      <Properties>
        <string name="Name">DynamicWorldGenerator</string>
        <string name="Source"><![CDATA[--!strict
-- DynamicWorldGenerator.lua - Enhanced Endless World Generation für Subway Surfers
-- Arbeitet zusammen mit SegmentSpawner für kohärente Welt-Generierung

local ReplicatedStorage = game:GetService("ReplicatedStorage")
local RunService = game:GetService("RunService")
local workspace = game:GetService("Workspace")

-- Import shared systems (will be loaded when needed to avoid circular dependencies)
local _GameConfig = nil -- Loaded on demand
local _SegmentSpawner = nil -- Integration point

-- Enhanced DynamicWorldGenerator mit SegmentSpawner Integration
local DynamicWorldGenerator = {}
DynamicWorldGenerator.__index = DynamicWorldGenerator

-- Type Definitions für bessere Copilot-Unterstützung
export type SpawnableObject = {
    type: string,
    position: Vector3,
    lane: number,
    zPosition: number,
    instance: Instance?,
    metadata: { [string]: any }?,
}

export type GeneratorState = {
    isActive: boolean,
    playerPosition: Vector3,
    lastSpawnZ: number,
    spawnedObjects: { SpawnableObject },
    difficulty: number,
    mode: string, -- "DYNAMIC" or "SEGMENT_BASED"
}

export type DynamicWorldGenerator = {
    state: GeneratorState,
    updateConnection: RBXScriptConnection?,
    segmentSpawnerIntegration: boolean,
    new: () -> DynamicWorldGenerator,
    start: (self: DynamicWorldGenerator, initialPlayerPosition: Vector3) -> (),
    stop: (self: DynamicWorldGenerator) -> (),
    updatePlayerPosition: (self: DynamicWorldGenerator, newPosition: Vector3) -> (),
}

-- Enhanced Configuration
local CONFIG = {
    SPAWN_DISTANCE = 300, -- Erweiterte Spawn-Distanz
    DESPAWN_DISTANCE = 100, -- Cleanup-Distanz
    COIN_SPAWN_RATE = 0.6, -- Ausbalancierte Spawn-Rate
    OBSTACLE_SPAWN_RATE = 0.3, -- Faire Obstacle-Rate
    POWERUP_SPAWN_RATE = 0.08, -- Seltene Power-Ups
    SEGMENT_LENGTH = 25, -- Koordiniert mit SegmentSpawner
    LANE_POSITIONS = { -8, 0, 8 }, -- Standardisierte Lane-Positionen
    INTEGRATION_MODE = "ENHANCED", -- Erweiterte Integration
}

function DynamicWorldGenerator.new(): DynamicWorldGenerator
    local self: DynamicWorldGenerator = setmetatable({}, DynamicWorldGenerator)

    self.state = {
        isActive = false,
        playerPosition = Vector3.new(0, 0, 0),
        lastSpawnZ = 0,
        spawnedObjects = {},
        difficulty = 1,
        mode = "DYNAMIC", -- Neue Eigenschaft für Integrations-Modus
    }

    self.updateConnection = nil :: RBXScriptConnection?
    self.segmentSpawnerIntegration = false -- Integration Flag

    return self
end

-- Start dynamic world generation
function DynamicWorldGenerator:start(initialPlayerPosition: Vector3)
    if self.state.isActive then
        return
    end

    print("🌍 Starting Dynamic World Generation")
    self.state.isActive = true
    self.state.playerPosition = initialPlayerPosition
    self.state.lastSpawnZ = initialPlayerPosition.Z

    -- Clear existing spawned objects
    self:clearSpawnedObjects()

    -- Generate initial world ahead of player
    self:generateInitialWorld()

    -- Start update loop
    self:startUpdateLoop()
end

-- Stop world generation
function DynamicWorldGenerator:stop()
    if not self.state.isActive then
        return
    end

    print("🛑 Stopping Dynamic World Generation")
    self.state.isActive = false

    if self.updateConnection then
        self.updateConnection:Disconnect()
        self.updateConnection = nil
    end

    -- Clean up spawned objects
    self:clearSpawnedObjects()
end

-- Update player position (called from PlayerController)
function DynamicWorldGenerator:updatePlayerPosition(newPosition: Vector3)
    self.state.playerPosition = newPosition

    -- Update difficulty based on distance traveled
    self.state.difficulty = math.min(5, math.floor(newPosition.Z / 500) + 1)
end

-- Main update loop
function DynamicWorldGenerator:startUpdateLoop()
    if self.updateConnection then
        self.updateConnection:Disconnect()
    end

    self.updateConnection = RunService.Heartbeat:Connect(function()
        if not self.state.isActive then
            return
        end

        -- Generate new segments ahead of player
        self:generateAhead()

        -- Clean up objects behind player
        self:cleanupBehind()
    end)
end

-- Generate initial world segments
function DynamicWorldGenerator:generateInitialWorld()
    local startZ: number = self.state.playerPosition.Z

    -- Generate segments ahead
    for i = 1, 10 do
        local segmentZ: number = startZ + (i * CONFIG.SEGMENT_LENGTH)
        self:generateSegment(segmentZ)
    end

    print("🌍 Initial world generated")
end

-- Generate objects ahead of player
function DynamicWorldGenerator:generateAhead()
    local playerZ: number = self.state.playerPosition.Z
    local spawnZ: number = playerZ + CONFIG.SPAWN_DISTANCE

    -- Check if we need to spawn new segments
    if spawnZ > self.state.lastSpawnZ + CONFIG.SEGMENT_LENGTH then
        local segmentZ: number = self.state.lastSpawnZ + CONFIG.SEGMENT_LENGTH
        self:generateSegment(segmentZ)
        self.state.lastSpawnZ = segmentZ
    end
end

-- Generate a single track segment
function DynamicWorldGenerator:generateSegment(zPosition: number)
    print(`🌍 Generating segment at Z: {zPosition}`)

    -- Generate coins (multiple patterns)
    self:generateCoins(zPosition)

    -- Generate obstacles (ensure fair gameplay)
    self:generateObstacles(zPosition)

    -- Generate power-ups (rare but valuable)
    self:generatePowerUps(zPosition)
end

-- Generate coins for a segment
function DynamicWorldGenerator:generateCoins(zPosition: number)
    if math.random() > CONFIG.COIN_SPAWN_RATE then
        return
    end

    local patterns = {
        "line", -- Straight line of coins
        "zigzag", -- Zigzag pattern
        "cluster", -- Coins in all lanes
        "single", -- Single coin in random lane
    }

    local pattern = patterns[math.random(#patterns)]

    if pattern == "line" then
        -- Line of coins in one lane
        local lane = math.random(1, 3)
        local laneX = CONFIG.LANE_POSITIONS[lane]

        for i = 0, 4 do
            local coinZ = zPosition + (i * 4)
            self:spawnCoin(Vector3.new(laneX, 3, coinZ), lane - 2)
        end
    elseif pattern == "zigzag" then
        -- Zigzag pattern across lanes
        for i = 0, 2 do
            local lane = (i % 3) + 1
            local laneX = CONFIG.LANE_POSITIONS[lane]
            local coinZ = zPosition + (i * 6)
            self:spawnCoin(Vector3.new(laneX, 3, coinZ), lane - 2)
        end
    elseif pattern == "cluster" then
        -- Coins in all three lanes
        for lane = 1, 3 do
            local laneX = CONFIG.LANE_POSITIONS[lane]
            self:spawnCoin(Vector3.new(laneX, 3, zPosition), lane - 2)
        end
    elseif pattern == "single" then
        -- Single coin in random lane
        local lane = math.random(1, 3)
        local laneX = CONFIG.LANE_POSITIONS[lane]
        self:spawnCoin(Vector3.new(laneX, 3, zPosition), lane - 2)
    end
end

-- Generate obstacles for a segment
function DynamicWorldGenerator:generateObstacles(zPosition: number)
    if math.random() > CONFIG.OBSTACLE_SPAWN_RATE * self.state.difficulty then
        return
    end

    local obstacleTypes = {
        "TRAIN", -- Must jump over
        "BARRIER", -- Must slide under
        "WIDE_BARRIER", -- Blocks multiple lanes
    }

    local obstacleType = obstacleTypes[math.random(#obstacleTypes)]

    if obstacleType == "TRAIN" then
        -- Train in one lane - can be jumped over
        local lane = math.random(1, 3)
        local laneX = CONFIG.LANE_POSITIONS[lane]
        self:spawnObstacle("TRAIN", Vector3.new(laneX, 4, zPosition), lane - 2)
    elseif obstacleType == "BARRIER" then
        -- Low barrier - must slide under
        local lane = math.random(1, 3)
        local laneX = CONFIG.LANE_POSITIONS[lane]
        self:spawnObstacle("BARRIER", Vector3.new(laneX, 2, zPosition), lane - 2)
    elseif obstacleType == "WIDE_BARRIER" then
        -- Wide barrier blocking 2 lanes - must switch to safe lane
        local safeLane = math.random(1, 3)

        for lane = 1, 3 do
            if lane ~= safeLane then
                local laneX = CONFIG.LANE_POSITIONS[lane]
                self:spawnObstacle("WIDE_BARRIER", Vector3.new(laneX, 4, zPosition), lane - 2)
            end
        end
    end
end

-- Generate power-ups for a segment
function DynamicWorldGenerator:generatePowerUps(zPosition: number)
    if math.random() > CONFIG.POWERUP_SPAWN_RATE then
        return
    end

    local powerUpTypes = { "JETPACK", "MAGNET", "SHIELD", "SPEED_BOOST" }
    local powerUpType = powerUpTypes[math.random(#powerUpTypes)]

    -- Always spawn in center lane for visibility
    self:spawnPowerUp(powerUpType, Vector3.new(0, 4, zPosition), 0)
end

-- Spawn a coin object
function DynamicWorldGenerator:spawnCoin(position: Vector3, lane: number)
    local coin = Instance.new("Part")
    coin.Name = "Coin_" .. math.random(1000, 9999)
    coin.Size = Vector3.new(2, 2, 0.2)
    coin.Position = position
    coin.Material = Enum.Material.Neon
    coin.BrickColor = BrickColor.new("Bright yellow")
    coin.Shape = Enum.PartType.Cylinder
    coin.Anchored = true
    coin.CanCollide = false
    coin.Parent = workspace

    -- Add spinning animation
    local bodyAngularVelocity = Instance.new("BodyAngularVelocity")
    bodyAngularVelocity.AngularVelocity = Vector3.new(0, 10, 0)
    bodyAngularVelocity.MaxTorque = Vector3.new(0, math.huge, 0)
    bodyAngularVelocity.Parent = coin

    -- Add light effect
    local light = Instance.new("PointLight")
    light.Color = Color3.fromRGB(255, 215, 0)
    light.Brightness = 1
    light.Range = 8
    light.Parent = coin

    -- Track spawned object
    local spawnedObject: SpawnableObject = {
        type = "COIN",
        position = position,
        lane = lane,
        zPosition = position.Z,
        instance = coin,
    }

    table.insert(self.state.spawnedObjects, spawnedObject)

    print(`💰 Spawned coin at lane {lane}, Z: {position.Z}`)
end

-- Spawn an obstacle
function DynamicWorldGenerator:spawnObstacle(obstacleType: string, position: Vector3, lane: number)
    local obstacle = Instance.new("Part")
    obstacle.Name = obstacleType .. "_" .. math.random(1000, 9999)
    obstacle.Position = position
    obstacle.Material = Enum.Material.Concrete
    obstacle.BrickColor = BrickColor.new("Really red")
    obstacle.Anchored = true
    obstacle.CanCollide = false
    obstacle.Parent = workspace

    -- Configure based on type
    if obstacleType == "TRAIN" then
        obstacle.Size = Vector3.new(4, 6, 8)
        obstacle.BrickColor = BrickColor.new("Dark red")
    elseif obstacleType == "BARRIER" then
        obstacle.Size = Vector3.new(4, 3, 2)
        obstacle.BrickColor = BrickColor.new("Bright red")
    elseif obstacleType == "WIDE_BARRIER" then
        obstacle.Size = Vector3.new(4, 6, 4)
        obstacle.BrickColor = BrickColor.new("Really red")
    end

    -- Track spawned object
    local spawnedObject: SpawnableObject = {
        type = "OBSTACLE",
        position = position,
        lane = lane,
        zPosition = position.Z,
        instance = obstacle,
    }

    table.insert(self.state.spawnedObjects, spawnedObject)

    print(`🚧 Spawned {obstacleType} at lane {lane}, Z: {position.Z}`)
end

-- Spawn a power-up
function DynamicWorldGenerator:spawnPowerUp(powerUpType: string, position: Vector3, lane: number)
    local powerUp = Instance.new("Part")
    powerUp.Name = "PowerUp_" .. powerUpType .. "_" .. math.random(1000, 9999)
    powerUp.Size = Vector3.new(3, 3, 3)
    powerUp.Position = position
    powerUp.Material = Enum.Material.ForceField
    powerUp.BrickColor = BrickColor.new("Bright blue")
    powerUp.Shape = Enum.PartType.Block
    powerUp.Anchored = true
    powerUp.CanCollide = false
    powerUp.Parent = workspace

    -- Add floating animation
    local bodyPosition = Instance.new("BodyPosition")
    bodyPosition.MaxForce = Vector3.new(0, math.huge, 0)
    bodyPosition.Position = position
    bodyPosition.D = 500
    bodyPosition.P = 3000
    bodyPosition.Parent = powerUp

    -- Floating effect
    task.spawn(function()
        local startY = position.Y
        local time = 0

        while powerUp.Parent do
            time = time + 0.1
            bodyPosition.Position = Vector3.new(position.X, startY + math.sin(time) * 0.5, position.Z)
            task.wait(0.1)
        end
    end)

    -- Track spawned object
    local spawnedObject: SpawnableObject = {
        type = "POWERUP",
        position = position,
        lane = lane,
        zPosition = position.Z,
        instance = powerUp,
    }

    table.insert(self.state.spawnedObjects, spawnedObject)

    print(`⚡ Spawned {powerUpType} at lane {lane}, Z: {position.Z}`)
end

-- Clean up objects behind player
function DynamicWorldGenerator:cleanupBehind()
    local playerZ: number = self.state.playerPosition.Z
    local despawnZ: number = playerZ - CONFIG.DESPAWN_DISTANCE

    for i = #self.state.spawnedObjects, 1, -1 do
        local obj = self.state.spawnedObjects[i]

        if obj.zPosition < despawnZ then
            -- Remove from world
            if obj.instance and obj.instance.Parent then
                obj.instance:Destroy()
            end

            -- Remove from tracking
            table.remove(self.state.spawnedObjects, i)

            print(`🧹 Cleaned up {obj.type} at Z: {obj.zPosition}`)
        end
    end
end

-- Clear all spawned objects
function DynamicWorldGenerator:clearSpawnedObjects()
    for _, obj in ipairs(self.state.spawnedObjects) do
        if obj.instance and obj.instance.Parent then
            obj.instance:Destroy()
        end
    end

    self.state.spawnedObjects = {}
    print("🧹 All spawned objects cleared")
end

-- Get objects near position (for collision detection)
function DynamicWorldGenerator:getObjectsNear(position: Vector3, radius: number): { SpawnableObject }
    local nearbyObjects = {}

    for _, obj in ipairs(self.state.spawnedObjects) do
        if obj.instance and obj.instance.Parent then
            local distance: number = (obj.position - position).Magnitude
            if distance <= radius then
                table.insert(nearbyObjects, obj)
            end
        end
    end

    return nearbyObjects
end

-- Remove specific object (when collected)
function DynamicWorldGenerator:removeObject(objectToRemove: SpawnableObject)
    for i, obj in ipairs(self.state.spawnedObjects) do
        if obj == objectToRemove then
            if obj.instance and obj.instance.Parent then
                obj.instance:Destroy()
            end
            table.remove(self.state.spawnedObjects, i)
            break
        end
    end
end

-- Get current generator state
function DynamicWorldGenerator:getState(): GeneratorState
    return table.clone(self.state)
end

return DynamicWorldGenerator
]]></string>
      </Properties>
    </Item>
    <Item class="ModuleScript" referent="35">
      <Properties>
        <string name="Name">GameCoordinator</string>
        <string name="Source"><![CDATA[-- Game Coordinator - Integration zwischen allen Systemen
--!strict

local Players = game:GetService("Players")
local _RunService = game:GetService("RunService")
local _ServerStorage = game:GetService("ServerStorage")

-- Demand-Loading für Module um circular dependencies zu vermeiden
local DynamicWorldGenerator: any = nil
local GameLoopManager: any = nil

-- Lazy Loading Funktion
local function getDynamicWorldGenerator(): any?
    if not DynamicWorldGenerator then
        local success, module = pcall(function()
            local moduleScript = script.Parent:FindFirstChild("DynamicWorldGenerator")
            return if moduleScript then require(moduleScript) else nil
        end)
        if success and module then
            DynamicWorldGenerator = module
        else
            warn("[GameCoordinator] DynamicWorldGenerator konnte nicht geladen werden")
        end
    end
    return DynamicWorldGenerator
end

local function getGameLoopManager(): any?
    if not GameLoopManager then
        local success, module = pcall(function()
            local moduleScript = script.Parent:FindFirstChild("GameLoopManager")
            return if moduleScript then require(moduleScript) else nil
        end)
        if success and module then
            GameLoopManager = module
        else
            warn("[GameCoordinator] GameLoopManager konnte nicht geladen werden")
        end
    end
    return GameLoopManager
end

-- Type Definitions für bessere Type-Safety
export type GameSession = {
    startTime: number,
    initiatingPlayer: Player,
}

export type GameCoordinatorStatus = {
    initialized: boolean,
    activeSession: boolean,
    worldGeneratorActive: boolean,
    gameLoopState: string,
    playerCount: number,
}

local GameCoordinator = {}
GameCoordinator.__index = GameCoordinator

export type GameCoordinator = typeof(setmetatable(
    {} :: {
        gameLoopManager: any,
        worldGenerator: any,
        isInitialized: boolean,
        activeSession: GameSession?,
    },
    GameCoordinator
))

function GameCoordinator.new(): GameCoordinator
    local self = setmetatable({}, GameCoordinator) :: GameCoordinator

    -- Prüfe ob Module verfügbar sind (lazy loading)
    local worldGen = getDynamicWorldGenerator()
    local gameLoop = getGameLoopManager()

    if not worldGen or not gameLoop then
        warn("🔧 GameCoordinator: Einige Module konnten nicht geladen werden, verwende Fallback")
        self.gameLoopManager = nil
        self.worldGenerator = nil
    else
        -- Initialize components
        self.gameLoopManager = gameLoop.new()
        self.worldGenerator = worldGen.new()
    end

    self.isInitialized = false
    self.activeSession = nil

    return self
end -- Initialize the complete game system
function GameCoordinator:initialize(): boolean
    if self.isInitialized then
        warn("🎮 GameCoordinator already initialized")
        return true
    end

    print("🎮 Initializing Subway Surfers Game Coordinator...")

    -- Prüfe kritische Abhängigkeiten
    if not self.gameLoopManager or not self.worldGenerator then
        warn("❌ GameCoordinator: Kritische Komponenten fehlen")
        return false
    end

    -- Setup player management
    self:setupPlayerManagement()

    -- Wait for first player to start the system
    if #Players:GetPlayers() > 0 then
        -- Players already in game
        for _, player in ipairs(Players:GetPlayers()) do
            self:handlePlayerJoined(player)
        end
    else
        -- Wait for first player
        Players.PlayerAdded:Connect(function(player)
            self:handlePlayerJoined(player)
        end)
    end

    self.isInitialized = true
    print("✅ Game Coordinator initialized successfully")
    return true
end

-- Setup player connection management
function GameCoordinator:setupPlayerManagement()
    Players.PlayerAdded:Connect(function(player)
        self:handlePlayerJoined(player)
    end)

    Players.PlayerRemoving:Connect(function(player)
        self:handlePlayerLeaving(player)
    end)
end

-- Handle player joining
function GameCoordinator:handlePlayerJoined(player: Player)
    print(`👤 Player {player.Name} joined - setting up game environment`)

    -- Initialize player in game systems
    task.spawn(function()
        -- Wait for character
        local character = player.Character or player.CharacterAdded:Wait()
        local _humanoid = character:WaitForChild("Humanoid")
        local rootPart = character:WaitForChild("HumanoidRootPart") :: BasePart

        -- Position player at start
        rootPart.Position = Vector3.new(0, 5, 0)

        -- Auto-start game for immediate play
        self:startGameSession(player)
    end)
end

-- Handle player leaving
function GameCoordinator:handlePlayerLeaving(player: Player)
    print(`👤 Player {player.Name} leaving`)

    -- Cleanup handled by GameLoopManager
end

-- Start a new game session
function GameCoordinator:startGameSession(initiatingPlayer: Player)
    print(`🚀 Starting game session for {initiatingPlayer.Name}`)

    -- Start world generation
    local playerPosition = Vector3.new(0, 5, 0)
    if initiatingPlayer.Character and initiatingPlayer.Character:FindFirstChild("HumanoidRootPart") then
        local rootPart = initiatingPlayer.Character:FindFirstChild("HumanoidRootPart") :: BasePart
        playerPosition = rootPart.Position
    end

    if self.worldGenerator and self.worldGenerator.start then
        self.worldGenerator:start(playerPosition)
    end

    -- Start game loop
    if self.gameLoopManager and self.gameLoopManager.startGame then
        self.gameLoopManager:startGame(initiatingPlayer)
    end

    -- Set up integration between systems
    self:integrateGameSystems()

    self.activeSession = {
        startTime = tick(),
        initiatingPlayer = initiatingPlayer,
    }

    print("✅ Game session started successfully")
end

-- Integrate game systems to work together
function GameCoordinator:integrateGameSystems()
    -- Create connection between PlayerController and WorldGenerator
    -- This will be called from PlayerController when position updates

    -- Store reference for global access
    _G.GameCoordinator = self
    _G.WorldGenerator = self.worldGenerator
    _G.GameLoop = self.gameLoopManager

    print("🔗 Game systems integrated")
end

-- Update world based on player position (called from PlayerController)
function GameCoordinator:updateWorldForPlayer(player: Player, position: Vector3)
    if self.worldGenerator and self.worldGenerator.state and self.worldGenerator.state.isActive then
        if self.worldGenerator.updatePlayerPosition then
            self.worldGenerator:updatePlayerPosition(position)
        end
    end
end

-- Get world objects near position (for collision detection)
function GameCoordinator:getWorldObjectsNear(position: Vector3, radius: number): { any }
    if self.worldGenerator and self.worldGenerator.getObjectsNear then
        return self.worldGenerator:getObjectsNear(position, radius)
    end
    return {}
end

-- Handle object collection (coins, power-ups)
function GameCoordinator:handleObjectCollection(player: Player, objectType: string, value: any)
    if not self.gameLoopManager then
        return
    end

    if objectType == "COIN" then
        if self.gameLoopManager.handleCoinCollected then
            self.gameLoopManager:handleCoinCollected(player, value or 10)
        end
    elseif objectType == "POWERUP" then
        if self.gameLoopManager.handlePowerUpCollected then
            self.gameLoopManager:handlePowerUpCollected(player, value)
        end
    end
end

-- Handle player collision with obstacle
function GameCoordinator:handlePlayerCollision(player: Player, obstacleType: string)
    if self.gameLoopManager and self.gameLoopManager.handlePlayerCollision then
        self.gameLoopManager:handlePlayerCollision(player, obstacleType)
    end
end

-- Stop current game session
function GameCoordinator:stopGameSession(reason: string)
    print(`🛑 Stopping game session: {reason}`)

    if self.worldGenerator and self.worldGenerator.stop then
        self.worldGenerator:stop()
    end

    if self.gameLoopManager and self.gameLoopManager.endGame then
        self.gameLoopManager:endGame(reason)
    end

    self.activeSession = nil
end

-- Restart game session
function GameCoordinator:restartGameSession(player: Player)
    print(`🔄 Restarting game session for {player.Name}`)

    self:stopGameSession("Manual restart")

    task.wait(1) -- Brief pause for cleanup

    self:startGameSession(player)
end

-- Get system status
function GameCoordinator:getStatus(): GameCoordinatorStatus
    return {
        initialized = self.isInitialized,
        activeSession = self.activeSession ~= nil,
        worldGeneratorActive = self.worldGenerator and self.worldGenerator.state and self.worldGenerator.state.isActive
            or false,
        gameLoopState = self.gameLoopManager
                and self.gameLoopManager.getGameState
                and self.gameLoopManager:getGameState()
            or "UNKNOWN",
        playerCount = #Players:GetPlayers(),
    }
end

-- Cleanup systems
function GameCoordinator:cleanup()
    print("🧹 Cleaning up Game Coordinator")

    if self.worldGenerator and self.worldGenerator.stop then
        self.worldGenerator:stop()
    end

    if self.gameLoopManager and self.gameLoopManager.cleanup then
        self.gameLoopManager:cleanup()
    end

    -- Clear global references
    _G.GameCoordinator = nil
    _G.WorldGenerator = nil
    _G.GameLoop = nil

    self.isInitialized = false
    print("✅ Game Coordinator cleanup complete")
end

return GameCoordinator
]]></string>
      </Properties>
    </Item>
    <Item class="ModuleScript" referent="36">
      <Properties>
        <string name="Name">GameLoopManager</string>
        <string name="Source"><![CDATA[-- Game Loop Manager für Subway Surfers Style Game
--!strict

local Players = game:GetService("Players")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local RunService = game:GetService("RunService")
local _TweenService = game:GetService("TweenService") -- Prefix with _ to silence warning

local GameLoopManager = {}
GameLoopManager.__index = GameLoopManager

-- Game States
local GameState = {
    MENU = "MENU",
    STARTING = "STARTING",
    PLAYING = "PLAYING",
    PAUSED = "PAUSED",
    GAME_OVER = "GAME_OVER",
    RESTARTING = "RESTARTING",
}

-- Type Definitions für bessere Type Safety
export type RemoteEventsType = {
    GameStart: RemoteEvent?,
    GameEnd: RemoteEvent?,
    GameRestart: RemoteEvent?,
    PlayerCollision: RemoteEvent?,
    CoinCollected: RemoteEvent?,
    PowerUpCollected: RemoteEvent?,
    ScoreUpdate: RemoteEvent?,
}

export type SessionDataType = {
    sessionId: string,
    state: string,
    startTime: number,
    endTime: number?,
    players: { PlayerGameData },
    worldGenerator: any?,
    currentSpeed: number,
    difficulty: number,
}

-- Type Definitions
type PlayerGameData = {
    player: Player,
    score: number,
    isAlive: boolean,
    startTime: number,
    endTime: number?,
    distance: number,
    coinsCollected: number,
    powerUpsUsed: number,
}

type GameSession = {
    sessionId: string,
    state: string,
    startTime: number,
    endTime: number?,
    players: { PlayerGameData },
    worldGenerator: any?,
    currentSpeed: number,
    difficulty: number,
}

function GameLoopManager.new()
    local self = setmetatable({}, GameLoopManager)

    self.currentSession = nil :: SessionDataType?
    self.gameState = GameState.MENU
    self.updateConnection = nil :: RBXScriptConnection?
    self.remoteEvents = {} :: RemoteEventsType

    self:setupRemoteEvents()
    self:setupPlayerConnections()

    return self
end

-- Setup Remote Events
function GameLoopManager:setupRemoteEvents()
    -- Setup folders if they don't exist
    local remoteEventsFolder = ReplicatedStorage:FindFirstChild("RemoteEvents")
    if not remoteEventsFolder then
        local newFolder = Instance.new("Folder")
        newFolder.Name = "RemoteEvents"
        newFolder.Parent = ReplicatedStorage
        remoteEventsFolder = newFolder
    end

    -- Ensure remoteEventsFolder is valid
    assert(remoteEventsFolder, "Failed to create RemoteEvents folder")

    -- Game control events
    local gameStartEvent = Instance.new("RemoteEvent")
    gameStartEvent.Name = "GameStart"
    gameStartEvent.Parent = remoteEventsFolder
    self.remoteEvents.GameStart = gameStartEvent

    local gameEndEvent = Instance.new("RemoteEvent")
    gameEndEvent.Name = "GameEnd"
    gameEndEvent.Parent = remoteEventsFolder
    self.remoteEvents.GameEnd = gameEndEvent

    local gameRestartEvent = Instance.new("RemoteEvent")
    gameRestartEvent.Name = "GameRestart"
    gameRestartEvent.Parent = remoteEventsFolder
    self.remoteEvents.GameRestart = gameRestartEvent

    -- Player action events
    local playerCollisionEvent = Instance.new("RemoteEvent")
    playerCollisionEvent.Name = "PlayerCollision"
    playerCollisionEvent.Parent = remoteEventsFolder
    self.remoteEvents.PlayerCollision = playerCollisionEvent

    local coinCollectedEvent = Instance.new("RemoteEvent")
    coinCollectedEvent.Name = "CoinCollected"
    coinCollectedEvent.Parent = remoteEventsFolder
    self.remoteEvents.CoinCollected = coinCollectedEvent

    local powerUpCollectedEvent = Instance.new("RemoteEvent")
    powerUpCollectedEvent.Name = "PowerUpCollected"
    powerUpCollectedEvent.Parent = remoteEventsFolder
    self.remoteEvents.PowerUpCollected = powerUpCollectedEvent

    -- Score update event
    local scoreUpdateEvent = Instance.new("RemoteEvent")
    scoreUpdateEvent.Name = "ScoreUpdate"
    scoreUpdateEvent.Parent = remoteEventsFolder
    self.remoteEvents.ScoreUpdate = scoreUpdateEvent

    -- Connect event handlers
    self:connectEventHandlers()

    print("🎮 Game Loop Manager - Remote Events Setup Complete")
end

-- Connect Remote Event Handlers
function GameLoopManager:connectEventHandlers()
    -- Game start request
    self.remoteEvents.GameStart.OnServerEvent:Connect(function(player)
        self:startGame(player)
    end)

    -- Game restart request
    self.remoteEvents.GameRestart.OnServerEvent:Connect(function(player)
        self:restartGame(player)
    end)

    -- Player collision with obstacle
    self.remoteEvents.PlayerCollision.OnServerEvent:Connect(function(player, obstacleType)
        self:handlePlayerCollision(player, obstacleType)
    end)

    -- Coin collected
    self.remoteEvents.CoinCollected.OnServerEvent:Connect(function(player, coinValue)
        self:handleCoinCollected(player, coinValue or 10)
    end)

    -- Power-up collected
    self.remoteEvents.PowerUpCollected.OnServerEvent:Connect(function(player, powerUpType)
        self:handlePowerUpCollected(player, powerUpType)
    end)

    print("🎮 Event handlers connected")
end

-- Setup player connections for join/leave events
function GameLoopManager:setupPlayerConnections()
    Players.PlayerAdded:Connect(function(player)
        self:onPlayerJoined(player)
    end)

    Players.PlayerRemoving:Connect(function(player)
        self:onPlayerLeaving(player)
    end)
end

-- Handle player joining
function GameLoopManager:onPlayerJoined(player: Player)
    print(`🎮 Player {player.Name} joined the game`)

    -- Initialize player data in leaderstats
    local leaderstats = Instance.new("Folder")
    leaderstats.Name = "leaderstats"
    leaderstats.Parent = player

    local score = Instance.new("IntValue")
    score.Name = "Score"
    score.Value = 0
    score.Parent = leaderstats

    local coins = Instance.new("IntValue")
    coins.Name = "Coins"
    coins.Value = 0
    coins.Parent = leaderstats

    local distance = Instance.new("IntValue")
    distance.Name = "Distance"
    distance.Value = 0
    distance.Parent = leaderstats

    -- Send current game state to player
    self:sendGameStateToPlayer(player)
end

-- Handle player leaving
function GameLoopManager:onPlayerLeaving(player: Player)
    print(`🎮 Player {player.Name} left the game`)

    -- Remove player from current session if active
    if self.currentSession then
        for i, playerData: PlayerGameData in ipairs(self.currentSession.players) do
            if playerData.player == player then
                table.remove(self.currentSession.players, i)
                break
            end
        end

        -- End game if no players left
        if #self.currentSession.players == 0 then
            self:endGame("No players remaining")
        end
    end
end

-- Start a new game session
function GameLoopManager:startGame(requestingPlayer: Player)
    if self.gameState == GameState.PLAYING then
        print(`🎮 Game already in progress - {requestingPlayer.Name} cannot start`)
        return
    end

    print(`🎮 Starting new game session - requested by {requestingPlayer.Name}`)

    -- Create new session
    local sessionId = tostring(tick())
    self.currentSession = {
        sessionId = sessionId,
        state = GameState.STARTING,
        startTime = tick(),
        endTime = nil,
        players = {},
        worldGenerator = nil,
        currentSpeed = 20,
        difficulty = 1,
    }

    -- Add all current players to session
    for _, player in ipairs(Players:GetPlayers()) do
        local playerData: PlayerGameData = {
            player = player,
            score = 0,
            isAlive = true,
            startTime = tick(),
            endTime = nil,
            distance = 0,
            coinsCollected = 0,
            powerUpsUsed = 0,
        }
        if self.currentSession then
            table.insert(self.currentSession.players, playerData)
        end

        -- Reset player stats (leaderstats prüfen und erstellen falls nötig)
        local leaderstats = player:FindFirstChild("leaderstats")
        if leaderstats then
            local scoreValue = leaderstats:FindFirstChild("Score") :: IntValue?
            local coinsValue = leaderstats:FindFirstChild("Coins") :: IntValue?
            local distanceValue = leaderstats:FindFirstChild("Distance") :: IntValue?

            if scoreValue then
                scoreValue.Value = 0
            end
            if coinsValue then
                coinsValue.Value = 0
            end
            if distanceValue then
                distanceValue.Value = 0
            end
        end
    end

    -- Update game state
    self.gameState = GameState.PLAYING
    if self.currentSession then
        self.currentSession.state = GameState.PLAYING
    end

    -- Initialize world generator
    self:initializeWorldGenerator()

    -- Start game loop
    self:startGameLoop()

    -- Notify all clients
    self.remoteEvents.GameStart:FireAllClients({
        sessionId = sessionId,
        startTime = self.currentSession.startTime,
    })

    print(`🎮 Game session {sessionId} started with {#self.currentSession.players} players`)
end

-- Initialize world generator
function GameLoopManager:initializeWorldGenerator()
    -- This will be connected to DynamicWorldGenerator when integrated
    print("🌍 World Generator initialized")

    -- For now, create basic world elements
    task.spawn(function()
        self:createBasicGameWorld()
    end)
end

-- Create basic game world
function GameLoopManager:createBasicGameWorld()
    local workspace = game:GetService("Workspace")

    -- Create spawn platform
    local spawnPlatform = Instance.new("Part")
    spawnPlatform.Name = "SpawnPlatform"
    spawnPlatform.Size = Vector3.new(50, 2, 50)
    spawnPlatform.Position = Vector3.new(0, 0, 0)
    spawnPlatform.Material = Enum.Material.Concrete
    spawnPlatform.BrickColor = BrickColor.new("Dark grey") -- Korrekte BrickColor Bezeichnung
    spawnPlatform.Anchored = true
    spawnPlatform.Parent = workspace

    -- Create initial track segments
    for i = 1, 20 do
        local segment = Instance.new("Part")
        segment.Name = `TrackSegment_{i}`
        segment.Size = Vector3.new(24, 1, 20)
        segment.Position = Vector3.new(0, -1, i * 20)
        segment.Material = Enum.Material.Asphalt
        segment.BrickColor = BrickColor.new("Really black")
        segment.Anchored = true
        segment.Parent = workspace
    end

    print("🌍 Basic game world created")
end

-- Start main game loop
function GameLoopManager:startGameLoop()
    if self.updateConnection then
        self.updateConnection:Disconnect()
    end

    self.updateConnection = RunService.Heartbeat:Connect(function(deltaTime)
        if self.gameState == GameState.PLAYING and self.currentSession then
            self:updateGameSession(deltaTime)
        end
    end)

    print("🎮 Game loop started")
end

-- Update game session
function GameLoopManager:updateGameSession(deltaTime: number)
    if not self.currentSession then
        return
    end

    local session = self.currentSession
    local currentTime = tick()
    local elapsedTime = currentTime - session.startTime

    -- Update game difficulty over time
    session.difficulty = math.min(5, math.floor(elapsedTime / 30) + 1)
    session.currentSpeed = 20 + (session.difficulty * 5)

    -- Update player distances and scores
    for _, playerData in ipairs(session.players) do
        if playerData.isAlive then
            -- Calculate distance based on time
            local playerElapsed = currentTime - playerData.startTime
            playerData.distance = math.floor(playerElapsed * session.currentSpeed / 10)

            -- Calculate score (distance + coins)
            playerData.score = (playerData.distance :: number) + ((playerData.coinsCollected :: number) * 10)

            -- Update leaderstats
            local leaderstats = playerData.player:FindFirstChild("leaderstats")
            if leaderstats then
                local scoreValue = leaderstats:FindFirstChild("Score") :: IntValue?
                local distanceValue = leaderstats:FindFirstChild("Distance") :: IntValue?
                local coinsValue = leaderstats:FindFirstChild("Coins") :: IntValue?

                if scoreValue then
                    scoreValue.Value = playerData.score
                end
                if distanceValue then
                    distanceValue.Value = playerData.distance
                end
                if coinsValue then
                    coinsValue.Value = playerData.coinsCollected
                end
            end
        end
    end

    -- Check if all players are dead
    local alivePlayers = 0
    for _, playerData in ipairs(session.players) do
        if playerData.isAlive then
            alivePlayers = alivePlayers + 1
        end
    end

    if alivePlayers == 0 then
        self:endGame("All players eliminated")
    end
end

-- Handle player collision with obstacle
function GameLoopManager:handlePlayerCollision(player: Player, obstacleType: string)
    if not self.currentSession then
        return
    end

    local playerData = self:getPlayerData(player)
    if not playerData or not playerData.isAlive then
        return
    end

    print(`💥 {player.Name} collided with {obstacleType}`)

    -- Mark player as dead
    playerData.isAlive = false
    playerData.endTime = tick()

    -- Notify client
    self.remoteEvents.GameEnd:FireClient(player, {
        reason = "collision",
        obstacleType = obstacleType,
        finalScore = playerData.score,
        distance = playerData.distance,
        coinsCollected = playerData.coinsCollected,
    })

    -- Check if game should end
    local alivePlayers = 0
    for _, pData in ipairs(self.currentSession.players) do
        if pData.isAlive then
            alivePlayers = alivePlayers + 1
        end
    end

    if alivePlayers == 0 then
        self:endGame("All players eliminated")
    end
end

-- Handle coin collection
function GameLoopManager:handleCoinCollected(player: Player, coinValue: number)
    if not self.currentSession then
        return
    end

    local playerData = self:getPlayerData(player)
    if not playerData or not playerData.isAlive then
        return
    end

    playerData.coinsCollected = (playerData.coinsCollected :: number) + 1
    playerData.score = (playerData.score :: number) + (coinValue :: number)

    print(`💰 {player.Name} collected coin - Total: {playerData.coinsCollected}`)

    -- Update leaderstats
    local leaderstats = player:FindFirstChild("leaderstats")
    if leaderstats then
        local coinsValue = leaderstats:FindFirstChild("Coins") :: IntValue?
        local scoreValue = leaderstats:FindFirstChild("Score") :: IntValue?

        if coinsValue then
            coinsValue.Value = playerData.coinsCollected
        end
        if scoreValue then
            scoreValue.Value = playerData.score
        end
    end

    -- Notify client
    self.remoteEvents.ScoreUpdate:FireClient(player, {
        score = playerData.score,
        coins = playerData.coinsCollected,
        coinValue = coinValue,
    })
end

-- Handle power-up collection
function GameLoopManager:handlePowerUpCollected(player: Player, powerUpType: string)
    if not self.currentSession then
        return
    end

    local playerData = self:getPlayerData(player)
    if not playerData or not playerData.isAlive then
        return
    end

    playerData.powerUpsUsed = (playerData.powerUpsUsed :: number) + 1

    print(`⚡ {player.Name} collected {powerUpType} power-up`)

    -- Apply power-up effects (to be implemented in PlayerController)
    self.remoteEvents.PowerUpCollected:FireClient(player, {
        powerUpType = powerUpType,
        duration = self:getPowerUpDuration(powerUpType),
    })
end

-- Get power-up duration
function GameLoopManager:getPowerUpDuration(powerUpType: string): number
    local durations = {
        JETPACK = 5,
        MAGNET = 8,
        SHIELD = 10,
        SPEED_BOOST = 6,
    }

    return durations[powerUpType] or 5
end

-- Get player data from session
function GameLoopManager:getPlayerData(player: Player): PlayerGameData?
    if not self.currentSession then
        return nil
    end

    for _, playerData: PlayerGameData in ipairs(self.currentSession.players) do
        if playerData.player == player then
            return playerData
        end
    end

    return nil
end

-- End current game session
function GameLoopManager:endGame(reason: string)
    if not self.currentSession then
        return
    end

    print(`🎮 Ending game session: {reason}`)

    self.gameState = GameState.GAME_OVER
    if self.currentSession then
        self.currentSession.state = GameState.GAME_OVER
        self.currentSession.endTime = tick()
    end

    -- Stop game loop
    local connection = self.updateConnection
    if connection then
        connection:Disconnect()
    end
    (self :: any).updateConnection = nil

    -- Calculate final scores and send results
    local results = {}
    for _, playerData in ipairs(self.currentSession.players) do
        local result = {
            playerName = playerData.player.Name,
            score = playerData.score,
            distance = playerData.distance,
            coinsCollected = playerData.coinsCollected,
            powerUpsUsed = playerData.powerUpsUsed,
            survivalTime = (playerData.endTime or self.currentSession.endTime) - playerData.startTime,
        }
        table.insert(results, result)
    end

    -- Sort by score
    table.sort(results, function(a: any, b: any)
        return (a.score :: number) > (b.score :: number)
    end)

    -- Notify all clients
    self.remoteEvents.GameEnd:FireAllClients({
        reason = reason,
        results = results,
        sessionDuration = self.currentSession.endTime - self.currentSession.startTime,
    })

    print(
        `🎮 Game session ended - Duration: {math.floor(self.currentSession.endTime - self.currentSession.startTime)}s`
    )
end

-- Restart game
function GameLoopManager:restartGame(requestingPlayer: Player)
    print(`🔄 Game restart requested by {requestingPlayer.Name}`)

    -- End current game if active
    if self.currentSession then
        self:endGame("Game restarted")
    end

    -- Wait a moment for cleanup
    task.wait(1)

    -- Start new game
    self:startGame(requestingPlayer)
end

-- Send current game state to player
function GameLoopManager:sendGameStateToPlayer(player: Player)
    local gameStateData = {
        state = self.gameState,
        sessionActive = self.currentSession ~= nil,
        sessionId = self.currentSession and self.currentSession.sessionId or nil,
    }

    -- Send via a dedicated event or existing one
    if self.remoteEvents.ScoreUpdate then
        self.remoteEvents.ScoreUpdate:FireClient(player, gameStateData)
    end
end

-- Get current game state
function GameLoopManager:getGameState(): string
    return self.gameState
end

-- Get current session info
function GameLoopManager:getCurrentSession()
    return self.currentSession
end

-- Cleanup on destruction
function GameLoopManager:cleanup()
    local connection = self.updateConnection
    if connection then
        connection:Disconnect()
    end
    (self :: any).updateConnection = nil

    -- Clean up remote events
    for _, remoteEvent in pairs(self.remoteEvents) do
        if remoteEvent and remoteEvent.Parent then
            remoteEvent:Destroy()
        end
    end

    print("🎮 Game Loop Manager cleaned up")
end

-- Diese Datei enthält die Hauptspiellogik für das Spiel

-- Initialisierung der Spielschleife
function GameLoopManager:Start()
    -- Spiel-Update-Logik hier
end

-- Funktion zum Stoppen der Spielschleife
function GameLoopManager:Stop()
    -- Logik zum Stoppen der Spielschleife
end

return GameLoopManager
]]></string>
      </Properties>
    </Item>
    <Item class="ModuleScript" referent="37">
      <Properties>
        <string name="Name">ObstacleService</string>
        <string name="Source"><![CDATA[-- ObstacleService.lua - Subway Surfers inspired obstacle spawning system
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local RunService = game:GetService("RunService")
local TweenService = game:GetService("TweenService")
local Workspace = game:GetService("Workspace")

local SharedFolder = ReplicatedStorage:WaitForChild("Shared")
local GameConfig = require(SharedFolder:WaitForChild("GameConfig"))
local SubwaySurfersGameplay = require(SharedFolder:WaitForChild("SubwaySurfersGameplay"))

local ObstacleService = {}
ObstacleService.ActiveObstacles = {}
ObstacleService.ActiveCollectibles = {}
ObstacleService.SpawnPosition = 0
ObstacleService.LastSpawnTime = 0
ObstacleService.IsActive = false

-- Initialize obstacle service
function ObstacleService:Initialize()
    self.SpawnPosition = GameConfig.World.spawnDistance
    self.LastSpawnTime = tick()

    -- Create obstacle containers
    self:CreateObstacleContainers()

    print("[ObstacleService] Obstacle service initialized")
end

-- Create containers for obstacles
function ObstacleService:CreateObstacleContainers()
    local gameWorld = Workspace:FindFirstChild("GameWorld")
    if not gameWorld then
        gameWorld = Instance.new("Folder")
        gameWorld.Name = "GameWorld"
        gameWorld.Parent = Workspace
    end

    local obstacles = gameWorld:FindFirstChild("Obstacles")
    if not obstacles then
        obstacles = Instance.new("Folder")
        obstacles.Name = "Obstacles"
        obstacles.Parent = gameWorld
    end

    local collectibles = gameWorld:FindFirstChild("Collectibles")
    if not collectibles then
        collectibles = Instance.new("Folder")
        collectibles.Name = "Collectibles"
        collectibles.Parent = gameWorld
    end

    self.ObstacleContainer = obstacles
    self.CollectibleContainer = collectibles
end

-- Start spawning obstacles
function ObstacleService:StartSpawning()
    self.IsActive = true
    self.LastSpawnTime = tick()

    -- Connect spawning loop
    self.SpawnConnection = RunService.Heartbeat:Connect(function()
        self:UpdateSpawning()
    end)

    print("[ObstacleService] Started spawning obstacles")
end

-- Stop spawning obstacles
function ObstacleService:StopSpawning()
    self.IsActive = false

    if self.SpawnConnection then
        self.SpawnConnection:Disconnect()
        self.SpawnConnection = nil
    end

    print("[ObstacleService] Stopped spawning obstacles")
end

-- Update spawning logic
function ObstacleService:UpdateSpawning()
    if not self.IsActive then
        return
    end

    local currentTime = tick()
    local timeSinceLastSpawn = currentTime - self.LastSpawnTime

    -- Get current speed settings
    local speedSettings = SubwaySurfersGameplay.GetSpeedForDistance(self.SpawnPosition)
    local spawnInterval = 1 / speedSettings.spawnRate

    if timeSinceLastSpawn >= spawnInterval then
        self:SpawnObstaclePattern()
        self.LastSpawnTime = currentTime
    end

    -- Clean up distant obstacles
    self:CleanupDistantObstacles()
end

-- Spawn obstacle pattern
function ObstacleService:SpawnObstaclePattern()
    -- Choose random pattern based on difficulty
    local patterns = SubwaySurfersGameplay.TrackPatterns
    local pattern = patterns[math.random(1, #patterns)]

    -- Spawn obstacles for this pattern
    self:SpawnPatternObstacles(pattern)

    -- Spawn collectibles for this pattern
    self:SpawnPatternCollectibles(pattern)

    -- Update spawn position
    self.SpawnPosition = self.SpawnPosition + pattern.length
end

-- Spawn obstacles for a specific pattern
function ObstacleService:SpawnPatternObstacles(pattern)
    for i, obstacleType in ipairs(pattern.obstacles) do
        local obstacleData = SubwaySurfersGameplay.ObstacleTypes[obstacleType]
        if obstacleData then
            -- Choose random lane (avoid all lanes being blocked)
            local availableLanes = { -1, 0, 1 }
            local lane = availableLanes[math.random(1, #availableLanes)]

            -- Create obstacle
            local obstacle = self:CreateObstacle(obstacleType, obstacleData, lane)
            if obstacle then
                table.insert(self.ActiveObstacles, {
                    part = obstacle,
                    type = obstacleType,
                    lane = lane,
                    spawnZ = self.SpawnPosition,
                })
            end
        end
    end
end

-- Create physical obstacle
function ObstacleService:CreateObstacle(obstacleType, obstacleData, lane)
    local obstacle = Instance.new("Part")
    obstacle.Name = obstacleData.name
    obstacle.Size = Vector3.new(obstacleData.width, obstacleData.height, 2)
    obstacle.Material = Enum.Material.Concrete
    obstacle.BrickColor = BrickColor.new("Dark stone grey")
    obstacle.Anchored = true
    obstacle.CanCollide = true

    -- Position in lane
    local laneX = SubwaySurfersGameplay.GetLanePosition(lane)
    obstacle.Position = Vector3.new(laneX, obstacleData.height / 2, self.SpawnPosition)

    -- Add collision detection
    local function onTouched(hit)
        local humanoid = hit.Parent:FindFirstChild("Humanoid")
        if humanoid then
            self:HandleObstacleCollision(obstacle, obstacleType, humanoid.Parent)
        end
    end
    obstacle.Touched:Connect(onTouched)

    -- Add visual effects based on type
    if obstacleType == "TRAIN" then
        obstacle.BrickColor = BrickColor.new("Really red")
        -- Add train-like decorations
        local stripe = Instance.new("Part")
        stripe.Size = Vector3.new(obstacleData.width, 0.5, 2)
        stripe.Material = Enum.Material.Neon
        stripe.BrickColor = BrickColor.new("Bright yellow")
        stripe.Anchored = true
        stripe.CanCollide = false
        stripe.Position = obstacle.Position + Vector3.new(0, obstacleData.height / 3, 0)
        stripe.Parent = self.ObstacleContainer
    end

    obstacle.Parent = self.ObstacleContainer
    return obstacle
end

-- Spawn collectibles for pattern
function ObstacleService:SpawnPatternCollectibles(pattern)
    if pattern.coins == "line" then
        self:SpawnCoinLine()
    elseif pattern.coins == "scattered" then
        self:SpawnScatteredCoins()
    elseif pattern.coins == "bonus" then
        self:SpawnBonusCollectibles()
    end

    -- Spawn power-up if pattern includes it
    if pattern.powerup then
        self:SpawnPowerUp()
    end
end

-- Spawn line of coins
function ObstacleService:SpawnCoinLine()
    local coinData = SubwaySurfersGameplay.CollectibleTypes.COIN
    local lane = math.random(-1, 1) -- Random lane
    local laneX = SubwaySurfersGameplay.GetLanePosition(lane)

    for i = 1, 10 do
        local coin = self:CreateCollectible("COIN", coinData, laneX, self.SpawnPosition + (i * 3))
        if coin then
            table.insert(self.ActiveCollectibles, {
                part = coin,
                type = "COIN",
                lane = lane,
                spawnZ = self.SpawnPosition + (i * 3),
            })
        end
    end
end

-- Spawn scattered coins
function ObstacleService:SpawnScatteredCoins()
    local coinData = SubwaySurfersGameplay.CollectibleTypes.COIN

    for i = 1, 5 do
        local lane = math.random(-1, 1)
        local laneX = SubwaySurfersGameplay.GetLanePosition(lane)
        local zOffset = math.random(0, 30)

        local coin = self:CreateCollectible("COIN", coinData, laneX, self.SpawnPosition + zOffset)
        if coin then
            table.insert(self.ActiveCollectibles, {
                part = coin,
                type = "COIN",
                lane = lane,
                spawnZ = self.SpawnPosition + zOffset,
            })
        end
    end
end

-- Spawn bonus collectibles
function ObstacleService:SpawnBonusCollectibles()
    -- Spawn mystery box
    local boxData = SubwaySurfersGameplay.CollectibleTypes.MYSTERY_BOX
    local lane = math.random(-1, 1)
    local laneX = SubwaySurfersGameplay.GetLanePosition(lane)

    local mysteryBox = self:CreateCollectible("MYSTERY_BOX", boxData, laneX, self.SpawnPosition + 15)
    if mysteryBox then
        table.insert(self.ActiveCollectibles, {
            part = mysteryBox,
            type = "MYSTERY_BOX",
            lane = lane,
            spawnZ = self.SpawnPosition + 15,
        })
    end
end

-- Spawn power-up
function ObstacleService:SpawnPowerUp()
    local powerUpTypes = { "JETPACK", "SUPER_SNEAKERS", "COIN_MAGNET", "MULTIPLIER" }
    local powerUpType = powerUpTypes[math.random(1, #powerUpTypes)]
    local powerUpData = SubwaySurfersGameplay.PowerUps[powerUpType]

    local lane = math.random(-1, 1)
    local laneX = SubwaySurfersGameplay.GetLanePosition(lane)

    local powerUp = self:CreatePowerUp(powerUpType, powerUpData, laneX, self.SpawnPosition + 20)
    if powerUp then
        table.insert(self.ActiveCollectibles, {
            part = powerUp,
            type = powerUpType,
            lane = lane,
            spawnZ = self.SpawnPosition + 20,
        })
    end
end

-- Create physical collectible
function ObstacleService:CreateCollectible(collectibleType, collectibleData, x, z)
    local collectible = Instance.new("Part")
    collectible.Name = collectibleData.name
    collectible.Size = collectibleData.size or Vector3.new(1, 1, 1)
    collectible.Material = Enum.Material.Neon
    collectible.BrickColor = BrickColor.new(collectibleData.color)
    collectible.Anchored = true
    collectible.CanCollide = false
    collectible.Shape = Enum.PartType.Cylinder

    -- Position
    collectible.Position = Vector3.new(x, 3, z)

    -- Add spinning animation with nil check
    local rotationSpeed = collectibleData.rotationSpeed or 1 -- Default to 1 if nil
    local spinTween = TweenService:Create(
        collectible,
        TweenInfo.new(1 / rotationSpeed, Enum.EasingStyle.Linear, Enum.EasingDirection.InOut, -1),
        { Rotation = Vector3.new(0, 360, 0) }
    )
    spinTween:Play()

    -- Add collection detection
    local function onTouched(hit)
        local parent = hit.Parent
        if not parent then
            return
        end

        local humanoid = parent:FindFirstChild("Humanoid")
        if humanoid then
            self:HandleCollectibleCollection(collectible, collectibleType, parent)
        end
    end
    collectible.Touched:Connect(onTouched)

    collectible.Parent = self.CollectibleContainer
    return collectible
end

-- Create power-up
function ObstacleService:CreatePowerUp(powerUpType, powerUpData, x, z)
    local powerUp = Instance.new("Part")
    powerUp.Name = powerUpData.name
    powerUp.Size = Vector3.new(2, 2, 2)
    powerUp.Material = Enum.Material.ForceField
    powerUp.BrickColor = BrickColor.new(powerUpData.color)
    powerUp.Anchored = true
    powerUp.CanCollide = false
    powerUp.Shape = Enum.PartType.Ball

    -- Position
    powerUp.Position = Vector3.new(x, 4, z)

    -- Add floating animation
    local floatTween = TweenService:Create(
        powerUp,
        TweenInfo.new(2, Enum.EasingStyle.Sine, Enum.EasingDirection.InOut, -1, true),
        { Position = Vector3.new(x, 5, z) }
    )
    floatTween:Play()

    -- Add collection detection
    local function onTouched(hit)
        local humanoid = hit.Parent:FindFirstChild("Humanoid")
        if humanoid then
            self:HandlePowerUpCollection(powerUp, powerUpType, humanoid.Parent)
        end
    end
    powerUp.Touched:Connect(onTouched)

    powerUp.Parent = self.CollectibleContainer
    return powerUp
end

-- Handle obstacle collision
function ObstacleService:HandleObstacleCollision(obstacle, obstacleType, character)
    -- Remove obstacle to prevent multiple collisions
    obstacle:Destroy()

    -- Remove from active obstacles
    for i, obstacleData in ipairs(self.ActiveObstacles) do
        if obstacleData.part == obstacle then
            table.remove(self.ActiveObstacles, i)
            break
        end
    end

    print("[ObstacleService] Player hit obstacle:", obstacleType)
end

-- Handle collectible collection
function ObstacleService:HandleCollectibleCollection(collectible, collectibleType, character)
    -- Remove collectible
    collectible:Destroy()

    -- Remove from active collectibles
    for i, collectibleData in ipairs(self.ActiveCollectibles) do
        if collectibleData.part == collectible then
            table.remove(self.ActiveCollectibles, i)
            break
        end
    end

    print("[ObstacleService] Player collected:", collectibleType)
end

-- Handle power-up collection
function ObstacleService:HandlePowerUpCollection(powerUp, powerUpType, character)
    -- Remove power-up
    powerUp:Destroy()

    -- Remove from active collectibles
    for i, collectibleData in ipairs(self.ActiveCollectibles) do
        if collectibleData.part == powerUp then
            table.remove(self.ActiveCollectibles, i)
            break
        end
    end

    print("[ObstacleService] Player collected power-up:", powerUpType)
end

-- Clean up distant obstacles and collectibles
function ObstacleService:CleanupDistantObstacles()
    local playerPosition = 0 -- This should be updated with actual player position

    -- Clean up obstacles
    for i = #self.ActiveObstacles, 1, -1 do
        local obstacleData = self.ActiveObstacles[i]
        if obstacleData.spawnZ < playerPosition - GameConfig.World.despawnDistance then
            obstacleData.part:Destroy()
            table.remove(self.ActiveObstacles, i)
        end
    end

    -- Clean up collectibles
    for i = #self.ActiveCollectibles, 1, -1 do
        local collectibleData = self.ActiveCollectibles[i]
        if collectibleData.spawnZ < playerPosition - GameConfig.World.despawnDistance then
            collectibleData.part:Destroy()
            table.remove(self.ActiveCollectibles, i)
        end
    end
end

-- Reset service
function ObstacleService:Reset()
    self:StopSpawning()

    -- Clear all obstacles
    for _, obstacleData in ipairs(self.ActiveObstacles) do
        obstacleData.part:Destroy()
    end
    self.ActiveObstacles = {}

    -- Clear all collectibles
    for _, collectibleData in ipairs(self.ActiveCollectibles) do
        collectibleData.part:Destroy()
    end
    self.ActiveCollectibles = {}

    -- Reset spawn position
    self.SpawnPosition = GameConfig.World.spawnDistance
end

return ObstacleService
]]></string>
      </Properties>
    </Item>
    <Item class="ModuleScript" referent="38">
      <Properties>
        <string name="Name">PlayerDataService</string>
        <string name="Source"><![CDATA[-- PlayerDataService.lua - Handle player data loading and saving
local DataStoreService = game:GetService("DataStoreService")
local ReplicatedStorage = game:GetService("ReplicatedStorage")

local SharedFolder = ReplicatedStorage:WaitForChild("Shared")
local GameState = require(SharedFolder:WaitForChild("GameState"))

local PlayerDataService = {}

-- Data store for player data
local PlayerDataStore = DataStoreService:GetDataStore("PlayerData_v1")

-- Cache for loaded player data
local PlayerCache = {}

-- Load player data from DataStore
function PlayerDataService:LoadPlayerData(player)
    if PlayerCache[player.UserId] then
        return PlayerCache[player.UserId]
    end

    local success, playerData = pcall(function()
        return PlayerDataStore:GetAsync(player.UserId)
    end)

    if success and playerData then
        -- Validate and merge with defaults
        local data = {}
        for key, defaultValue in pairs(GameState.DefaultPlayerData) do
            data[key] = playerData[key] or defaultValue
        end

        PlayerCache[player.UserId] = data
        print("[PlayerDataService] Loaded data for:", player.Name)
        return data
    else
        -- Return default data for new players
        local defaultData = {}
        for key, value in pairs(GameState.DefaultPlayerData) do
            defaultData[key] = value
        end

        PlayerCache[player.UserId] = defaultData
        print("[PlayerDataService] Created new data for:", player.Name)
        return defaultData
    end
end

-- Save player data to DataStore
function PlayerDataService:SavePlayerData(player, playerData)
    if not playerData then
        return
    end

    local success, error = pcall(function()
        PlayerDataStore:SetAsync(player.UserId, playerData)
    end)

    if success then
        PlayerCache[player.UserId] = playerData
        print("[PlayerDataService] Saved data for:", player.Name)
    else
        warn("[PlayerDataService] Failed to save data for:", player.Name, error)
    end
end

-- Get cached player data
function PlayerDataService:GetCachedData(player)
    return PlayerCache[player.UserId]
end

-- Update specific player data field
function PlayerDataService:UpdatePlayerField(player, field, value)
    local playerData = PlayerCache[player.UserId]
    if playerData and playerData[field] ~= nil then
        playerData[field] = value
        return true
    end
    return false
end

-- Clean up cache when player leaves
function PlayerDataService:CleanupPlayerCache(player)
    PlayerCache[player.UserId] = nil
end

return PlayerDataService
]]></string>
      </Properties>
    </Item>
    <Item class="ModuleScript" referent="39">
      <Properties>
        <string name="Name">PowerUpService</string>
        <string name="Source"><![CDATA[--!strict
-- PowerUpService.lua - Server-side power-up management for Subway Surfers
local PowerUpService = {}

local Players = game:GetService("Players")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local RunService = game:GetService("RunService")

-- Import shared modules with error handling
local GameConfig
local SubwaySurfersGameplay

local success, error = pcall(function()
    GameConfig = require(ReplicatedStorage:WaitForChild("Shared"):WaitForChild("GameConfig"))
end)

if not success then
    warn("[PowerUpService] GameConfig not found, using fallback:", error)
    GameConfig = {
        PowerUps = {
            JETPACK = { name = "Jetpack", duration = 8, effect = "flight", color = Color3.fromRGB(255, 140, 0) },
            SUPER_SNEAKERS = {
                name = "Super Sneakers",
                duration = 10,
                effect = "highjump",
                color = Color3.fromRGB(0, 255, 0),
            },
            COIN_MAGNET = {
                name = "Coin Magnet",
                duration = 15,
                effect = "magnet",
                color = Color3.fromRGB(255, 0, 255),
            },
            MULTIPLIER = {
                name = "2x Multiplier",
                duration = 20,
                effect = "doublescore",
                color = Color3.fromRGB(255, 255, 0),
            },
        },
    }
end

local success2, error2 = pcall(function()
    SubwaySurfersGameplay = require(ReplicatedStorage:WaitForChild("Shared"):WaitForChild("SubwaySurfersGameplay"))
end)

if not success2 then
    warn("[PowerUpService] SubwaySurfersGameplay not found, using fallback:", error2)
    SubwaySurfersGameplay = {
        PowerUps = {
            JETPACK = { name = "Jetpack", duration = 8, effect = "flight", color = Color3.fromRGB(255, 140, 0) },
            SUPER_SNEAKERS = {
                name = "Super Sneakers",
                duration = 10,
                effect = "highjump",
                color = Color3.fromRGB(0, 255, 0),
            },
            COIN_MAGNET = {
                name = "Coin Magnet",
                duration = 15,
                effect = "magnet",
                color = Color3.fromRGB(255, 0, 255),
            },
            MULTIPLIER = {
                name = "2x Multiplier",
                duration = 20,
                effect = "doublescore",
                color = Color3.fromRGB(255, 255, 0),
            },
        },
    }
end

-- Types
export type PowerUpInstance = {
    player: Player,
    powerUpType: string,
    startTime: number,
    duration: number,
    active: boolean,
}

-- Local storage
local activePowerUps: { [Player]: { [string]: PowerUpInstance } } = {}
local powerUpEffects = {}
local cleanupConnections = {}

-- Remote Events
local PowerUpActivatedEvent: RemoteEvent
local PowerUpDeactivatedEvent: RemoteEvent

-- Initialize PowerUpService
function PowerUpService:Initialize()
    print("[PowerUpService] Initializing power-up system...")

    -- Wait for ReplicatedStorage to be ready
    if not ReplicatedStorage:FindFirstChild("RemoteEvents") then
        warn("[PowerUpService] RemoteEvents folder not found, creating it...")
        local remoteEventsFolder = Instance.new("Folder")
        remoteEventsFolder.Name = "RemoteEvents"
        remoteEventsFolder.Parent = ReplicatedStorage
    end

    local RemoteEvents = ReplicatedStorage:WaitForChild("RemoteEvents")

    -- Wait for all required remote events
    PowerUpActivatedEvent = RemoteEvents:WaitForChild("PowerUpActivated")
    PowerUpDeactivatedEvent = RemoteEvents:WaitForChild("PowerUpDeactivated")

    print("[PowerUpService] Remote events connected successfully")

    -- Initialize power-up effects
    local success, errorMsg = pcall(function()
        self:SetupPowerUpEffects()
    end)

    if not success then
        warn("[PowerUpService] Failed to setup power-up effects:", errorMsg)
    end

    -- Connect to update loop
    RunService.Heartbeat:Connect(function(deltaTime)
        self:UpdateActivePowerUps(deltaTime)
    end)

    -- Handle player cleanup
    Players.PlayerRemoving:Connect(function(player)
        self:CleanupPlayerPowerUps(player)
    end)

    print("[PowerUpService] ✅ PowerUpService initialized successfully")
end

-- Setup power-up effects
function PowerUpService:SetupPowerUpEffects()
    -- Create default power-up data
    local powerUpDefaults = {
        JETPACK = {
            name = "Jetpack",
            duration = 8,
            effect = "flight",
            color = Color3.fromRGB(255, 140, 0),
        },
        SUPER_SNEAKERS = {
            name = "Super Sneakers",
            duration = 10,
            effect = "highjump",
            color = Color3.fromRGB(0, 255, 0),
        },
        COIN_MAGNET = {
            name = "Coin Magnet",
            duration = 15,
            effect = "magnet",
            color = Color3.fromRGB(255, 0, 255),
        },
        MULTIPLIER = {
            name = "2x Multiplier",
            duration = 20,
            effect = "doublescore",
            color = Color3.fromRGB(255, 255, 0),
        },
    }

    -- Use power-ups from GameConfig if available, otherwise use defaults
    if GameConfig and GameConfig.PowerUps then
        powerUpEffects = {}
        for powerUpType, defaultData in pairs(powerUpDefaults) do
            if GameConfig.PowerUps[powerUpType] then
                powerUpEffects[powerUpType] = GameConfig.PowerUps[powerUpType]
                print("[PowerUpService] Using GameConfig power-up:", powerUpType)
            else
                warn("[PowerUpService] GameConfig missing", powerUpType, "- using default")
                powerUpEffects[powerUpType] = defaultData
            end
        end
    else
        warn("[PowerUpService] GameConfig.PowerUps not available - using all defaults")
        powerUpEffects = powerUpDefaults
    end

    -- Also check SubwaySurfersGameplay as backup
    if SubwaySurfersGameplay and SubwaySurfersGameplay.PowerUps then
        for powerUpType, defaultData in pairs(powerUpDefaults) do
            if not powerUpEffects[powerUpType] and SubwaySurfersGameplay.PowerUps[powerUpType] then
                powerUpEffects[powerUpType] = SubwaySurfersGameplay.PowerUps[powerUpType]
                print("[PowerUpService] Using SubwaySurfersGameplay power-up:", powerUpType)
            end
        end
    end

    print("[PowerUpService] Power-up effects setup complete")

    -- Verify that we have the required power-ups
    local requiredPowerUps = { "JETPACK", "SUPER_SNEAKERS", "COIN_MAGNET", "MULTIPLIER" }
    for _, powerUpType in ipairs(requiredPowerUps) do
        if not powerUpEffects[powerUpType] then
            warn("[PowerUpService] Missing power-up:", powerUpType)
        else
            print("[PowerUpService] ✅", powerUpType, "configured successfully")
        end
    end
end

-- Activate power-up for a specific player
function PowerUpService:ActivatePowerUp(player: Player, powerUpType: string): boolean
    if not player or not player.Parent then
        warn("[PowerUpService] Invalid player for power-up activation")
        return false
    end

    local powerUpEffect = powerUpEffects[powerUpType]
    if not powerUpEffect then
        warn("[PowerUpService] Unknown power-up type:", powerUpType)
        return false
    end

    -- Check if already active
    if activePowerUps[player] and activePowerUps[player][powerUpType] then
        warn("[PowerUpService] Power-up", powerUpType, "already active for", player.Name)
        return false
    end

    -- Initialize player's power-up table if needed
    if not activePowerUps[player] then
        activePowerUps[player] = {}
    end

    -- Create power-up instance
    local powerUpInstance: PowerUpInstance = {
        player = player,
        powerUpType = powerUpType,
        startTime = tick(),
        duration = powerUpEffect.duration or 10,
        active = true,
    }

    activePowerUps[player][powerUpType] = powerUpInstance

    -- Apply power-up effect
    self:ApplyPowerUpEffect(player, powerUpType)

    -- Notify client
    if PowerUpActivatedEvent then
        PowerUpActivatedEvent:FireClient(player, powerUpType, powerUpInstance.duration)
    end

    print("[PowerUpService] Activated", powerUpType, "for", player.Name, "duration:", powerUpInstance.duration)
    return true
end

-- Apply power-up effect
function PowerUpService:ApplyPowerUpEffect(player: Player, powerUpType: string)
    local character = player.Character
    if not character then
        return
    end

    if powerUpType == "JETPACK" then
        self:ApplyJetpackEffect(player)
    elseif powerUpType == "SUPER_SNEAKERS" then
        self:ApplySuperSneakersEffect(player)
    elseif powerUpType == "COIN_MAGNET" then
        self:ApplyCoinMagnetEffect(player)
    elseif powerUpType == "MULTIPLIER" then
        self:ApplyMultiplierEffect(player)
    end
end

-- Apply Jetpack effect
function PowerUpService:ApplyJetpackEffect(player: Player)
    local character = player.Character
    if not character then
        return
    end

    local rootPart = character:FindFirstChild("HumanoidRootPart")
    if not rootPart then
        return
    end

    -- Add flight capability
    local bodyVelocity = Instance.new("BodyVelocity")
    bodyVelocity.MaxForce = Vector3.new(0, math.huge, 0)
    bodyVelocity.Velocity = Vector3.new(0, 25, 0)
    bodyVelocity.Name = "JetpackForce"
    bodyVelocity.Parent = rootPart

    print("[PowerUpService] Jetpack effect applied to", player.Name)
end

-- Apply Super Sneakers effect
function PowerUpService:ApplySuperSneakersEffect(player: Player)
    local character = player.Character
    if not character then
        return
    end

    local humanoid = character:FindFirstChild("Humanoid")
    if not humanoid then
        return
    end

    -- Store original values and enhance jump
    humanoid:SetAttribute("OriginalJumpPower", humanoid.JumpPower)
    humanoid.JumpPower = (humanoid.JumpPower or 50) * 2

    print("[PowerUpService] Super Sneakers effect applied to", player.Name)
end

-- Apply Coin Magnet effect
function PowerUpService:ApplyCoinMagnetEffect(player: Player)
    -- Coin magnet effect will be handled in the update loop
    print("[PowerUpService] Coin Magnet effect applied to", player.Name)
end

-- Apply Multiplier effect
function PowerUpService:ApplyMultiplierEffect(player: Player)
    -- Multiplier effect will be handled by score service
    print("[PowerUpService] Score Multiplier effect applied to", player.Name)
end

-- Deactivate power-up
function PowerUpService:DeactivatePowerUp(player: Player, powerUpType: string)
    if not activePowerUps[player] or not activePowerUps[player][powerUpType] then
        return
    end

    -- Remove power-up effect
    self:RemovePowerUpEffect(player, powerUpType)

    -- Remove from active list
    activePowerUps[player][powerUpType] = nil

    -- Notify client
    if PowerUpDeactivatedEvent then
        PowerUpDeactivatedEvent:FireClient(player, powerUpType)
    end

    print("[PowerUpService] Deactivated", powerUpType, "for", player.Name)
end

-- Remove power-up effect
function PowerUpService:RemovePowerUpEffect(player: Player, powerUpType: string)
    local character = player.Character
    if not character then
        return
    end

    if powerUpType == "JETPACK" then
        self:RemoveJetpackEffect(player)
    elseif powerUpType == "SUPER_SNEAKERS" then
        self:RemoveSuperSneakersEffect(player)
    elseif powerUpType == "COIN_MAGNET" then
        self:RemoveCoinMagnetEffect(player)
    elseif powerUpType == "MULTIPLIER" then
        self:RemoveMultiplierEffect(player)
    end
end

-- Remove Jetpack effect
function PowerUpService:RemoveJetpackEffect(player: Player)
    local character = player.Character
    if not character then
        return
    end

    local rootPart = character:FindFirstChild("HumanoidRootPart")
    if not rootPart then
        return
    end

    local jetpackForce = rootPart:FindFirstChild("JetpackForce")
    if jetpackForce then
        jetpackForce:Destroy()
    end
end

-- Remove Super Sneakers effect
function PowerUpService:RemoveSuperSneakersEffect(player: Player)
    local character = player.Character
    if not character then
        return
    end

    local humanoid = character:FindFirstChild("Humanoid")
    if not humanoid then
        return
    end

    -- Restore original jump power
    local originalJumpPower = humanoid:GetAttribute("OriginalJumpPower")
    if originalJumpPower then
        humanoid.JumpPower = originalJumpPower
        humanoid:SetAttribute("OriginalJumpPower", nil)
    end
end

-- Remove Coin Magnet effect
function PowerUpService:RemoveCoinMagnetEffect(player: Player)
    -- Nothing to remove for coin magnet
end

-- Remove Multiplier effect
function PowerUpService:RemoveMultiplierEffect(player: Player)
    -- Nothing to remove for multiplier
end

-- Update active power-ups
function PowerUpService:UpdateActivePowerUps(deltaTime: number)
    for player, playerPowerUps in pairs(activePowerUps) do
        for powerUpType, powerUpInstance in pairs(playerPowerUps) do
            if powerUpInstance.active then
                local elapsed = tick() - powerUpInstance.startTime
                if elapsed >= powerUpInstance.duration then
                    self:DeactivatePowerUp(player, powerUpType)
                end
            end
        end
    end
end

-- Check if player has power-up active
function PowerUpService:HasPowerUpActive(player: Player, powerUpType: string): boolean
    return activePowerUps[player] and activePowerUps[player][powerUpType] and activePowerUps[player][powerUpType].active
        or false
end

-- Get active power-ups for player
function PowerUpService:GetActivePowerUps(player: Player): { string }
    if not activePowerUps[player] then
        return {}
    end

    local active = {}
    for powerUpType, powerUpInstance in pairs(activePowerUps[player]) do
        if powerUpInstance.active then
            table.insert(active, powerUpType)
        end
    end
    return active
end

-- Clean up player power-ups
function PowerUpService:CleanupPlayerPowerUps(player: Player)
    if activePowerUps[player] then
        for powerUpType, _ in pairs(activePowerUps[player]) do
            self:DeactivatePowerUp(player, powerUpType)
        end
        activePowerUps[player] = nil
    end

    if cleanupConnections[player] then
        for _, connection in pairs(cleanupConnections[player]) do
            connection:Disconnect()
        end
        cleanupConnections[player] = nil
    end
end

-- Start tracking player
function PowerUpService:StartTrackingPlayer(player: Player)
    print("[PowerUpService] Started tracking power-ups for:", player.Name)
    activePowerUps[player] = {}
end

-- Stop tracking player
function PowerUpService:StopTrackingPlayer(player: Player)
    self:CleanupPlayerPowerUps(player)
    print("[PowerUpService] Stopped tracking power-ups for:", player.Name)
end

return PowerUpService
]]></string>
      </Properties>
    </Item>
    <Item class="ModuleScript" referent="40">
      <Properties>
        <string name="Name">RemoteEventsService</string>
        <string name="Source"><![CDATA[--!strict
-- RemoteEventsService.lua - Manages remote events and functions for client-server communication
local ReplicatedStorage = game:GetService("ReplicatedStorage")

local RemoteEventsService = {}

-- Create remote events and functions
function RemoteEventsService:Initialize()
    print("[RemoteEventsService] Initializing remote events...")

    -- Ensure RemoteEvents folder exists
    if not ReplicatedStorage:FindFirstChild("RemoteEvents") then
        local folder = Instance.new("Folder")
        folder.Name = "RemoteEvents"
        folder.Parent = ReplicatedStorage
    end

    -- Ensure RemoteFunctions folder exists
    if not ReplicatedStorage:FindFirstChild("RemoteFunctions") then
        local folder = Instance.new("Folder")
        folder.Name = "RemoteFunctions"
        folder.Parent = ReplicatedStorage
    end

    -- Ensure Modules folder exists
    if not ReplicatedStorage:FindFirstChild("Shared") then
        local folder = Instance.new("Folder")
        folder.Name = "Shared"
        folder.Parent = ReplicatedStorage
    end

    local remoteEventsFolder = ReplicatedStorage:WaitForChild("RemoteEvents")
    local remoteFunctionsFolder = ReplicatedStorage:WaitForChild("RemoteFunctions")

    -- Additional Remote Events (beyond what's in default.project.json)
    local additionalEvents = {
        "PowerUpActivated",
        "PowerUpDeactivated",
        "ObstacleSpawned",
        "CollectibleSpawned",
        "SegmentSpawned",
        "UIUpdate",
    }

    for _, eventName in ipairs(additionalEvents) do
        if not remoteEventsFolder:FindFirstChild(eventName) then
            local remoteEvent = Instance.new("RemoteEvent")
            remoteEvent.Name = eventName
            remoteEvent.Parent = remoteEventsFolder
        end
    end

    -- Additional Remote Functions
    local additionalFunctions = {
        "GetLeaderboard",
        "PurchaseItem",
    }

    for _, functionName in ipairs(additionalFunctions) do
        if not remoteFunctionsFolder:FindFirstChild(functionName) then
            local remoteFunction = Instance.new("RemoteFunction")
            remoteFunction.Name = functionName
            remoteFunction.Parent = remoteFunctionsFolder
        end
    end

    print("[RemoteEventsService] Remote events initialized successfully")
end

return RemoteEventsService
]]></string>
      </Properties>
    </Item>
    <Item class="ModuleScript" referent="41">
      <Properties>
        <string name="Name">ScoreService</string>
        <string name="Source"><![CDATA[--!nocheck
-- ScoreService.lua - Handle scoring and collectibles
local ReplicatedStorage = game:GetService("ReplicatedStorage")

local SharedFolder = ReplicatedStorage:WaitForChild("Shared")
local GameConfig = require(SharedFolder:WaitForChild("GameConfig"))
local GameState = require(SharedFolder:WaitForChild("GameState"))

local ScoreService = {}

-- Initialize ScoreService
function ScoreService:Initialize()
    print("[ScoreService] Score tracking system initialized")
end

-- Start tracking player score
function ScoreService:StartTrackingPlayer(player)
    print("[ScoreService] Started tracking score for:", player.Name)
end

-- Stop tracking player score
function ScoreService:StopTrackingPlayer(player)
    print("[ScoreService] Stopped tracking score for:", player.Name)
end

-- Process collectible for a specific player
function ScoreService:ProcessCollectible(player, collectibleType, value)
    local scoreGained = 0

    print("[ScoreService] Processing collectible for", player.Name, ":", collectibleType, "value:", value)

    -- Handle both "COIN" and "Coin" formats
    local normalizedType = string.upper(collectibleType)

    if normalizedType == "COIN" then
        scoreGained = GameConfig.Scores.coin * (value or 1)
        print("[ScoreService] Coin collected - base score:", GameConfig.Scores.coin)
    elseif normalizedType == "GEM" then
        scoreGained = GameConfig.Scores.gem * (value or 1)
        print("[ScoreService] Gem collected - base score:", GameConfig.Scores.gem)
    elseif normalizedType == "POWER_UP" or normalizedType == "POWERUP" then
        scoreGained = GameConfig.Scores.powerUp * (value or 1)
        print("[ScoreService] Power-up collected - base score:", GameConfig.Scores.powerUp)
    else
        warn("[ScoreService] Unknown collectible type:", collectibleType)
    end

    -- Apply score multiplier based on current speed
    local speedMultiplier = math.min(GameState.SessionData.currentSpeed / GameConfig.Gameplay.baseSpeed, 2)
    scoreGained = math.floor(scoreGained * speedMultiplier)

    print("[ScoreService] Final score after multiplier:", scoreGained, "multiplier:", speedMultiplier)

    return scoreGained
end

-- Process obstacle hit
function ScoreService:ProcessObstacleHit(player, obstacleType)
    print("[ScoreService] Player", player.Name, "hit obstacle:", obstacleType)
end

-- Calculate final score
function ScoreService:CalculateFinalScore(player)
    print("[ScoreService] Calculating final score for:", player.Name)
    return GameState.SessionData.currentScore or 0
end

-- Get session stats
function ScoreService:GetSessionStats(player)
    return {
        coinsCollected = 0,
        gemsCollected = 0,
        finalScore = 0,
    }
end

-- Process distance for scoring
function ScoreService:ProcessDistance(player, distance)
    if not player or not distance then
        warn("[ScoreService] Invalid parameters for ProcessDistance")
        return
    end

    -- Calculate distance-based score
    local distanceScore = self:CalculateDistanceScore(distance)

    print("[ScoreService] Processing distance for", player.Name, "- Distance:", distance, "Score:", distanceScore)

    -- Check for distance milestones
    self:CheckDistanceMilestones(player, distance)

    return distanceScore
end

-- Check distance milestones
function ScoreService:CheckDistanceMilestones(player, distance)
    if not player or not distance then
        return
    end

    -- Check for distance-based achievements/milestones
    local milestones = { 100, 500, 1000, 2500, 5000, 10000 }

    for _, milestone in ipairs(milestones) do
        if distance >= milestone and (distance - 1) < milestone then
            print("[ScoreService] 🎉 Distance milestone reached:", milestone, "by", player.Name)
            -- Here you could trigger achievements, bonus points, etc.
        end
    end
end

-- Process collectible and return score value (legacy compatibility)
function ScoreService:ProcessCollectible_Legacy(collectibleType, value)
    local scoreGained = 0

    print("[ScoreService] Processing collectible:", collectibleType, "value:", value)

    if collectibleType == GameState.CollectibleTypes.COIN then
        scoreGained = GameConfig.Scores.coin * (value or 1)
        print("[ScoreService] Coin collected - base score:", GameConfig.Scores.coin)
    elseif collectibleType == GameState.CollectibleTypes.GEM then
        scoreGained = GameConfig.Scores.gem * (value or 1)
        print("[ScoreService] Gem collected - base score:", GameConfig.Scores.gem)
    elseif collectibleType == GameState.CollectibleTypes.POWER_UP then
        scoreGained = GameConfig.Scores.powerUp * (value or 1)
        print("[ScoreService] Power-up collected - base score:", GameConfig.Scores.powerUp)
    else
        warn("[ScoreService] Unknown collectible type:", collectibleType)
    end

    -- Apply score multiplier based on current speed
    local speedMultiplier = math.min(GameState.SessionData.currentSpeed / GameConfig.Gameplay.baseSpeed, 2)
    scoreGained = math.floor(scoreGained * speedMultiplier)

    print("[ScoreService] Final score after multiplier:", scoreGained, "multiplier:", speedMultiplier)

    return scoreGained
end
-- Calculate combo multiplier
function ScoreService:CalculateComboMultiplier(consecutiveCollections)
    local multiplier = 1
    if consecutiveCollections >= 5 then
        multiplier = 1.5
    elseif consecutiveCollections >= 10 then
        multiplier = 2
    elseif consecutiveCollections >= 20 then
        multiplier = 3
    end
    return multiplier
end

-- Calculate score for distance traveled
function ScoreService:CalculateDistanceScore(distance)
    return math.floor(distance * GameConfig.Scores.distanceMultiplier)
end

-- Get score breakdown for end game screen
function ScoreService:GetScoreBreakdown(sessionData)
    return {
        baseScore = sessionData.currentScore or 0,
        distanceBonus = self:CalculateDistanceScore(sessionData.currentDistance or 0),
        collectibleBonus = (sessionData.collectiblesGathered or 0) * 5,
        survivalBonus = math.max(0, 100 - (sessionData.obstaclesHit or 0) * 10),
        speedBonus = math.floor(
            (sessionData.currentSpeed or GameConfig.Gameplay.baseSpeed) - GameConfig.Gameplay.baseSpeed
        ),
    }
end

return ScoreService
]]></string>
      </Properties>
    </Item>
    <Item class="Script" referent="42">
      <Properties>
        <string name="Name">ServiceInitializer</string>
        <token name="RunContext">0</token>
        <string name="Source"><![CDATA[-- ServiceInitializer.lua - Ensures proper loading order of services with Copilot optimization
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local RunService = game:GetService("RunService")

print("🔧 SERVICE INITIALIZER STARTING WITH AI OPTIMIZATION...")

-- Enhanced folder structure creation with validation
local function createFolderStructure()
    local folders = {
        { name = "RemoteEvents", required = true },
        { name = "RemoteFunctions", required = true },
        { name = "Shared", required = true },
        { name = "Modules", required = false }, -- Optional for compatibility
    }

    local createdCount = 0
    for _, folderInfo in ipairs(folders) do
        if not ReplicatedStorage:FindFirstChild(folderInfo.name) then
            local folder = Instance.new("Folder")
            folder.Name = folderInfo.name
            folder.Parent = ReplicatedStorage
            print("✅ Created required folder:", folderInfo.name)
            createdCount = createdCount + 1
        else
            print("✅ Folder exists:", folderInfo.name)
        end
    end

    print("📁 Folder structure validation complete -", createdCount, "new folders created")
end

-- Enhanced server signals with performance monitoring
local function createServerSignals()
    local signals = {
        { name = "ServerReady", initialValue = false },
        { name = "GameManagerReady", initialValue = false },
        { name = "ServicesReady", initialValue = false }, -- New enhanced signal
    }

    for _, signalInfo in ipairs(signals) do
        if not ReplicatedStorage:FindFirstChild(signalInfo.name) then
            local signal = Instance.new("BoolValue")
            signal.Name = signalInfo.name
            signal.Value = signalInfo.initialValue
            signal.Parent = ReplicatedStorage
            print("🚦 Created signal:", signalInfo.name)
        end
    end

    -- Add performance tracking
    local perfStats = Instance.new("StringValue")
    perfStats.Name = "ServerPerformance"
    perfStats.Value = "Initializing..."
    perfStats.Parent = ReplicatedStorage
end

-- Performance monitoring during initialization
local function trackInitializationPerformance()
    local startTime = tick()
    local memoryStart = collectgarbage("count")

    task.spawn(function()
        task.wait(1) -- Wait for initialization to complete

        local endTime = tick()
        local memoryEnd = collectgarbage("count")
        local initTime = endTime - startTime
        local memoryUsage = memoryEnd - memoryStart

        local perfStats = ReplicatedStorage:FindFirstChild("ServerPerformance")
        if perfStats then
            perfStats.Value = string.format("Init: %.2fs, Memory: %.1fKB", initTime, memoryUsage)
        end

        print("📊 Initialization Performance:")
        print("   ⏱️ Time:", string.format("%.2f", initTime), "seconds")
        print("   💾 Memory:", string.format("%.1f", memoryUsage), "KB")
    end)
end

-- Initialize in correct order with performance monitoring
createFolderStructure()
createServerSignals()
trackInitializationPerformance()

-- Mark server as ready after enhanced initialization
task.spawn(function()
    task.wait(0.5) -- Brief delay to ensure all systems are stable

    local serverReady = ReplicatedStorage:FindFirstChild("ServerReady")
    if serverReady then
        serverReady.Value = true
        print("🚦 ServerReady signal activated")
    end

    local servicesReady = ReplicatedStorage:FindFirstChild("ServicesReady")
    if servicesReady then
        servicesReady.Value = true
        print("🚦 ServicesReady signal activated")
    end
end)

print("✅ SERVICE INITIALIZER COMPLETED WITH AI OPTIMIZATION")

return {}
]]></string>
      </Properties>
    </Item>
    <Item class="Script" referent="43">
      <Properties>
        <string name="Name">SubwaySurfersLauncher</string>
        <token name="RunContext">0</token>
        <string name="Source"><![CDATA[-- Subway Surfers Game Launcher
-- Startet das komplette Spiel System
--!strict

local GameCoordinator = require(script.Parent.GameCoordinator)

-- Initialize the complete game system
print("🎮 SUBWAY SURFERS GAME - Starting...")
print("🚀 Loading Game Coordinator...")

local coordinator = GameCoordinator.new()
coordinator:initialize()

-- Store globally for other scripts to access
_G.SubwaySurfersGame = coordinator

print("✅ SUBWAY SURFERS GAME - Ready to play!")
print("👋 Players can now join and the game will start automatically")

-- Status check every 30 seconds
spawn(function()
    while true do
        wait(30)
        local status = coordinator:getStatus()
        print(
            `📊 Game Status: {status.playerCount} players, Active: {status.activeSession}, World: {status.worldGeneratorActive}`
        )
    end
end)
]]></string>
      </Properties>
    </Item>
    <Item class="ModuleScript" referent="44">
      <Properties>
        <string name="Name">WorldBuilder</string>
        <string name="Source"><![CDATA[--!strict
-- WorldBuilder.lua - Unified World Management für Subway Surfers
-- Koordiniert zwischen statischer Basis-Welt und dynamischer Segment-Generierung
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local Workspace = game:GetService("Workspace")

-- Import dependencies
local SubwaySurfersGameplay = require(ReplicatedStorage:WaitForChild("Shared"):WaitForChild("SubwaySurfersGameplay"))

-- WorldBuilder - Master World Coordinator
local WorldBuilder = {}
WorldBuilder.__index = WorldBuilder

-- State Management
local isInitialized = false
local worldSystemInstance = nil

-- Initialize the game world - UNIFIED APPROACH
function WorldBuilder.Initialize()
    if isInitialized then
        print("[WorldBuilder] ⚠️ World system already initialized - using existing world")
        return true
    end

    print("[WorldBuilder] 🌍 Starting Unified World System...")

    -- Step 1: Check for existing world (avoid conflicts)
    if WorldBuilder:_checkExistingWorld() then
        print("[WorldBuilder] ✅ Found existing world - integrating with current system")
        isInitialized = true
        return true
    end

    -- Step 2: Create base world infrastructure
    local baseWorldSuccess = WorldBuilder:_createBaseWorld()
    if not baseWorldSuccess then
        warn("[WorldBuilder] ❌ Failed to create base world infrastructure")
        return false
    end

    -- Step 3: Initialize dynamic systems (will be used later)
    WorldBuilder:_prepareDynamicSystems()

    isInitialized = true
    print("[WorldBuilder] ✅ Unified World System initialized successfully!")
    return true
end

-- Check if any world already exists (from other scripts)
function WorldBuilder:_checkExistingWorld(): boolean
    local existingWorldElements = {
        "SubwayTrack",
        "MainTrack",
        "SpawnPlatform",
        "SubwayTrain_1",
        "Coin_1",
        "LaneMarker_L",
    }

    for _, elementName in ipairs(existingWorldElements) do
        if Workspace:FindFirstChild(elementName) then
            print("[WorldBuilder] 🔍 Found existing world element:", elementName)
            return true
        end
    end

    return false
end

-- Create base world infrastructure (static elements)
function WorldBuilder:_createBaseWorld(): boolean
    local success = pcall(function()
        -- Create main track platform
        WorldBuilder:CreateTrack()

        -- Create lane navigation markers
        WorldBuilder:CreateLaneMarkers()

        -- Create player spawn point
        WorldBuilder:CreateSpawnPoint()

        -- Setup atmospheric lighting
        WorldBuilder:SetupLighting()

        print("[WorldBuilder] 🏗️ Base world infrastructure created")
    end)

    return success
end

-- Prepare dynamic systems (but don't start them yet)
function WorldBuilder:_prepareDynamicSystems()
    -- This will be called by GameCoordinator when game starts
    print("[WorldBuilder] 🔧 Dynamic systems prepared for activation")

    -- Store reference for later use by other systems
    _G.WorldBuilder = WorldBuilder
end

-- Create the main track/platform
function WorldBuilder:CreateTrack()
    local track = Instance.new("Part")
    track.Name = "MainTrack"
    track.Size = Vector3.new(24, 2, 1000) -- Wide platform for 3 lanes
    track.Position = Vector3.new(0, -1, 500) -- Extended forward
    track.Material = Enum.Material.Concrete
    track.BrickColor = BrickColor.new("Dark stone grey")
    track.Anchored = true
    track.Parent = Workspace

    -- Add track texture/pattern
    local surface = Instance.new("SurfaceGui")
    surface.Parent = track
    surface.Face = Enum.NormalId.Top

    -- Create basic subway track lines
    for i = 1, 3 do
        local line = Instance.new("Frame")
        line.Size = UDim2.new(0.02, 0, 1, 0)
        line.Position = UDim2.new((i - 1) * 0.33 + 0.16, 0, 0, 0)
        line.BackgroundColor3 = Color3.fromRGB(255, 255, 0)
        line.BorderSizePixel = 0
        line.Parent = surface
    end
end

-- Create lane divider markers
function WorldBuilder:CreateLaneMarkers()
    local leftLaneX = SubwaySurfersGameplay.GetLanePosition(-1)
    local _centerLaneX = SubwaySurfersGameplay.GetLanePosition(0)
    local rightLaneX = SubwaySurfersGameplay.GetLanePosition(1)

    -- Create lane marker posts every 50 studs
    for z = 0, 1000, 50 do
        -- Left lane markerss
        local leftMarker = Instance.new("Part")
        leftMarker.Name = "LeftLaneMarker"
        leftMarker.Size = Vector3.new(0.5, 8, 0.5)
        leftMarker.Position = Vector3.new(leftLaneX - 4, 4, z)
        leftMarker.Material = Enum.Material.Neon
        leftMarker.BrickColor = BrickColor.new("Bright yellow")
        leftMarker.Anchored = true
        leftMarker.Parent = Workspace

        -- Right lane marker
        local rightMarker = Instance.new("Part")
        rightMarker.Name = "RightLaneMarker"
        rightMarker.Size = Vector3.new(0.5, 8, 0.5)
        rightMarker.Position = Vector3.new(rightLaneX + 4, 4, z)
        rightMarker.Material = Enum.Material.Neon
        rightMarker.BrickColor = BrickColor.new("Bright yellow")
        rightMarker.Anchored = true
        rightMarker.Parent = Workspace
    end
end

-- Create player spawn point
function WorldBuilder:CreateSpawnPoint()
    local spawnPoint = Instance.new("SpawnLocation")
    spawnPoint.Name = "PlayerSpawn"
    spawnPoint.Size = Vector3.new(4, 1, 4)
    spawnPoint.Position = Vector3.new(0, 2, 0)
    spawnPoint.Material = Enum.Material.Neon
    spawnPoint.BrickColor = BrickColor.new("Bright green")
    spawnPoint.TopSurface = Enum.SurfaceType.Smooth
    spawnPoint.Anchored = true
    spawnPoint.Parent = Workspace

    -- Add spawn effect
    local light = Instance.new("PointLight")
    light.Color = Color3.fromRGB(0, 255, 0)
    light.Brightness = 2
    light.Range = 10
    light.Parent = spawnPoint
end

-- Set up game lighting and atmosphere
function WorldBuilder:SetupLighting()
    local Lighting = game:GetService("Lighting")

    -- Set lighting properties for subway atmosphere
    Lighting.Brightness = 0.5
    Lighting.Ambient = Color3.fromRGB(100, 100, 120)
    Lighting.ColorShift_Bottom = Color3.fromRGB(50, 50, 80)
    Lighting.ColorShift_Top = Color3.fromRGB(150, 150, 200)
    Lighting.OutdoorAmbient = Color3.fromRGB(80, 80, 100)
    Lighting.TimeOfDay = "14:00:00" -- Afternoon lighting
    Lighting.FogEnd = 500
    Lighting.FogStart = 100
    Lighting.FogColor = Color3.fromRGB(100, 100, 120)

    -- Add atmosphere effects
    local Atmosphere = Instance.new("Atmosphere")
    Atmosphere.Density = 0.3
    Atmosphere.Offset = 0.25
    Atmosphere.Color = Color3.fromRGB(199, 199, 199)
    Atmosphere.Decay = Color3.fromRGB(106, 112, 125)
    Atmosphere.Glare = 0.4
    Atmosphere.Haze = 1.8
    Atmosphere.Parent = Lighting

    -- Add some tunnel lighting
    for z = 0, 1000, 100 do
        local streetLight = Instance.new("Part")
        streetLight.Name = "StreetLight"
        streetLight.Size = Vector3.new(1, 12, 1)
        streetLight.Position = Vector3.new(-15, 6, z)
        streetLight.Material = Enum.Material.Metal
        streetLight.BrickColor = BrickColor.new("Dark stone grey")
        streetLight.Anchored = true
        streetLight.Parent = Workspace

        local light = Instance.new("PointLight")
        light.Color = Color3.fromRGB(255, 220, 150)
        light.Brightness = 1.5
        light.Range = 20
        light.Parent = streetLight

        -- Create matching light on the other side
        local streetLight2 = streetLight:Clone()
        streetLight2.Position = Vector3.new(15, 6, z)
        streetLight2.Parent = Workspace
    end
end

-- Create basic obstacles for testing
function WorldBuilder:CreateTestObstacles()
    -- Create a few test obstacles
    local obstacles = {
        { type = "TRAIN", lane = 0, z = 100 },
        { type = "BARRIER", lane = -1, z = 150 },
        { type = "TUNNEL_ENTRANCE", lane = 1, z = 200 },
    }

    for _, obstacleData in ipairs(obstacles) do
        local obstacleType = SubwaySurfersGameplay.ObstacleTypes[obstacleData.type]
        if obstacleType then
            local obstacle = Instance.new("Part")
            obstacle.Name = obstacleType.name
            obstacle.Size = Vector3.new(obstacleType.width, obstacleType.height, 2)
            obstacle.Position = Vector3.new(
                SubwaySurfersGameplay.GetLanePosition(obstacleData.lane),
                obstacleType.height / 2,
                obstacleData.z
            )
            obstacle.Material = Enum.Material.Metal
            obstacle.BrickColor = BrickColor.new("Really red")
            obstacle.Anchored = true
            obstacle.Parent = Workspace
        end
    end
end

-- Create test collectibles
function WorldBuilder:CreateTestCollectibles()
    -- Create some test coins
    for i = 1, 20 do
        local coin = Instance.new("Part")
        coin.Name = "TestCoin"
        coin.Size = Vector3.new(1, 1, 0.2)
        coin.Position = Vector3.new(SubwaySurfersGameplay.GetLanePosition(math.random(-1, 1)), 3, i * 10 + 50)
        coin.Material = Enum.Material.Neon
        coin.BrickColor = BrickColor.new("Bright yellow")
        coin.Shape = Enum.PartType.Cylinder
        coin.Anchored = true
        coin.Parent = Workspace

        -- Add spinning animation
        local spin = Instance.new("BodyAngularVelocity")
        spin.AngularVelocity = Vector3.new(0, 10, 0)
        spin.MaxTorque = Vector3.new(0, math.huge, 0)
        spin.Parent = coin
    end
end

return WorldBuilder
]]></string>
      </Properties>
    </Item>
    <Item class="Folder" referent="45">
      <Properties>
        <string name="Name">services</string>
      </Properties>
      <Item class="Script" referent="46">
        <Properties>
          <string name="Name">PlayerService</string>
          <token name="RunContext">0</token>
          <string name="Source"><![CDATA[--!strict
-- Diese Funktion aktualisiert die Spieler-Daten mit Typ-Sicherheit
export type PlayerData = {
    userId: number,
    displayName: string,
    coins: number,
    level: number,
}

function updatePlayerData(player: Player, data: PlayerData): boolean
    -- Implementation mit Typ-Validierung
    local success = pcall(function()
        -- Potenziell fehleranfällige Operation
        player:SetAttribute("coins", data.coins)
        player:SetAttribute("level", data.level)
    end)

    if not success then
        warn("Aktualisierung der Spieler-Daten fehlgeschlagen")
        return false
    end

    return true
end
]]></string>
        </Properties>
      </Item>
    </Item>
  </Item>
  <Item class="StarterPlayer" referent="47">
    <Properties>
      <string name="Name">StarterPlayer</string>
    </Properties>
    <Item class="StarterPlayerScripts" referent="48">
      <Properties>
        <string name="Name">StarterPlayerScripts</string>
      </Properties>
      <Item class="LocalScript" referent="49">
        <Properties>
          <string name="Name">EnhancedPlayerController</string>
          <string name="Source"><![CDATA[--!strict
-- Spieler-Controller für Endless Runner Spiel
-- Verwaltet Bewegung in drei Bahnen mit Sprung/Rutsch-Mechanik
local EnhancedPlayerController = {}

-- Typ-Definitionen
export type PlayerState = {
    lane: number,
    isJumping: boolean,
    isSliding: boolean,
}

export type EnhancedPlayerController = {
    MoveToLane: (self: EnhancedPlayerController, lane: number) -> (),
    Jump: (self: EnhancedPlayerController) -> (),
    Slide: (self: EnhancedPlayerController) -> (),
}

function EnhancedPlayerController.new(): EnhancedPlayerController
    -- Initialisierungscode hier
    return setmetatable({}, { __index = EnhancedPlayerController }) :: any
end

function EnhancedPlayerController:MoveToLane(lane: number)
    -- Logik für das Bewegen zwischen den Bahnen
end

function EnhancedPlayerController:Jump()
    -- Sprung-Logik hier
end

function EnhancedPlayerController:Slide()
    -- Rutsch-Logik hier
end

return EnhancedPlayerController
]]></string>
        </Properties>
      </Item>
      <Item class="Folder" referent="50">
        <Properties>
          <string name="Name">controllers</string>
        </Properties>
        <Item class="ModuleScript" referent="51">
          <Properties>
            <string name="Name">CameraController</string>
            <string name="Source"><![CDATA[--!strict
-- CameraController.lua - Handle camera movement and effects for Subway Surfers
local RunService = game:GetService("RunService")
local TweenService = game:GetService("TweenService")
local workspace = game:GetService("Workspace")

-- Typ-Definition für CameraController
export type CameraController = {
    Camera: Camera,
    Player: Player?,
    RootPart: BasePart?,
    CameraConnection: RBXScriptConnection?,
    OriginalCFrame: CFrame?,
    IsGameCameraActive: boolean,
    Initialize: (self: CameraController, player: Player, rootPart: BasePart) -> (),
    StartGameCamera: (self: CameraController) -> (),
    StopGameCamera: (self: CameraController) -> (),
    UpdateGameCamera: (self: CameraController) -> (),
    ReturnToMenu: (self: CameraController) -> (),
    ShakeCamera: (self: CameraController, intensity: number?) -> (),
    ApplyLaneTilt: (self: CameraController, direction: number) -> (),
    ApplySpeedEffect: (self: CameraController, isActive: boolean) -> (),
    SetFieldOfView: (self: CameraController, fov: number, duration: number?) -> Tween,
    Cleanup: (self: CameraController) -> (),
}

local CameraController = {} :: CameraController
CameraController.Camera = workspace.CurrentCamera
CameraController.Player = nil
CameraController.RootPart = nil
CameraController.CameraConnection = nil
CameraController.OriginalCFrame = nil
CameraController.IsGameCameraActive = false

-- Camera settings optimized for Subway Surfers
local CAMERA_OFFSET = Vector3.new(0, 8, -12) -- Behind and above player
local CAMERA_LOOK_AHEAD = 15 -- Look forward along track
local CAMERA_SMOOTHNESS = 0.15 -- Smooth following

-- Initialize camera controller
function CameraController:Initialize(player: Player, rootPart: BasePart)
    self.Player = player
    self.RootPart = rootPart
    self.OriginalCFrame = self.Camera.CFrame

    -- Set camera type to scriptable for full control
    self.Camera.CameraType = Enum.CameraType.Scriptable

    print("[CameraController] Camera initialized for Subway Surfers")
end

-- Start game camera following
function CameraController:StartGameCamera()
    if not self.RootPart then
        warn("[CameraController] No RootPart available")
        return
    end

    self.IsGameCameraActive = true

    -- Disconnect any existing connection
    if self.CameraConnection then
        self.CameraConnection:Disconnect()
    end

    -- Connect camera update to heartbeat for smooth following
    self.CameraConnection = RunService.Heartbeat:Connect(function()
        self:UpdateGameCamera()
    end)

    print("[CameraController] Game camera started - following player")

    -- Set initial camera position
    self:UpdateGameCamera()
end

-- Stop game camera
function CameraController:StopGameCamera()
    self.IsGameCameraActive = false

    if self.CameraConnection then
        self.CameraConnection:Disconnect()
    end
    self.CameraConnection = nil

    -- Return to default camera type
    self.Camera.CameraType = Enum.CameraType.Custom

    print("[CameraController] Game camera stopped")
end

-- Update camera position during gameplay - CRITICAL for proper orientation
function CameraController:UpdateGameCamera()
    if not self.RootPart or not self.IsGameCameraActive then
        return
    end

    local rootPosition: Vector3 = self.RootPart.Position
    local rootLookVector: Vector3 = self.RootPart.CFrame.LookVector

    -- Calculate camera position behind and above player
    local cameraPosition: Vector3 = rootPosition + CAMERA_OFFSET

    -- Look at position ahead of player along their facing direction
    local lookAtPosition: Vector3 = rootPosition + (rootLookVector * CAMERA_LOOK_AHEAD)

    -- Create target camera CFrame looking at the player's forward direction
    local targetCFrame = CFrame.lookAt(cameraPosition, lookAtPosition)

    -- Smooth camera movement
    self.Camera.CFrame = self.Camera.CFrame:Lerp(targetCFrame, CAMERA_SMOOTHNESS)
end

-- Return camera to menu position
function CameraController:ReturnToMenu()
    self:StopGameCamera()

    if self.OriginalCFrame then
        -- Smooth transition back to original position
        local tweenInfo = TweenInfo.new(1, Enum.EasingStyle.Quad, Enum.EasingDirection.Out)
        local tween = TweenService:Create(self.Camera, tweenInfo, { CFrame = self.OriginalCFrame })
        tween:Play()
    end

    print("[CameraController] Returned to menu camera")
end

-- Shake camera for collision effects
function CameraController:ShakeCamera(intensity: number?)
    if not self.IsGameCameraActive then
        return
    end

    local shakeIntensity: number = if intensity then intensity else 1
    local shakeAmount: number = 1.5 * shakeIntensity
    local shakeDuration: number = 0.3 * shakeIntensity

    -- Create shake effect
    local shakeStart = tick()

    local shakeConnection
    shakeConnection = RunService.Heartbeat:Connect(function()
        local elapsed = tick() - shakeStart
        if elapsed >= shakeDuration then
            shakeConnection:Disconnect()
            return
        end

        -- Calculate shake offset with decay
        local progress: number = elapsed / shakeDuration
        local shakeIntensity: number = (1 - progress) * shakeAmount

        local randomOffset: Vector3 = Vector3.new(
            (math.random() - 0.5) * shakeIntensity,
            (math.random() - 0.5) * shakeIntensity,
            0 -- Don't shake forward/backward
        )

        -- Apply shake to camera
        if self.IsGameCameraActive then
            self:UpdateGameCamera()
            self.Camera.CFrame = self.Camera.CFrame + randomOffset
        end
    end)
end

-- Lane switching camera tilt effect
function CameraController:ApplyLaneTilt(direction: number)
    if not self.IsGameCameraActive then
        return
    end

    -- Subtle camera roll when switching lanes (-1 = left, 1 = right)
    local tiltAmount = direction * 2 -- degrees

    -- Apply tilt effect
    spawn(function()
        local originalCFrame = self.Camera.CFrame
        local tiltedCFrame = originalCFrame * CFrame.Angles(0, 0, math.rad(tiltAmount))

        -- Quick tilt in
        local tweenInfo = TweenInfo.new(0.1, Enum.EasingStyle.Quad, Enum.EasingDirection.Out)
        local tiltTween = TweenService:Create(self.Camera, tweenInfo, { CFrame = tiltedCFrame })
        tiltTween:Play()

        -- Wait and tilt back
        tiltTween.Completed:Wait()
        task.wait(0.1)

        local returnTween = TweenService:Create(self.Camera, tweenInfo, { CFrame = originalCFrame })
        returnTween:Play()
    end)
end

-- Speed boost camera effect
function CameraController:ApplySpeedEffect(isActive)
    if isActive then
        -- Increase FOV for speed sensation
        self:SetFieldOfView(80, 0.3)
    else
        -- Return to normal FOV
        self:SetFieldOfView(70, 0.5)
    end
end

-- Set camera field of view
function CameraController:SetFieldOfView(fov: number, duration: number?): Tween
    local tweenDuration: number = if duration then duration else 0.5

    local tweenInfo = TweenInfo.new(tweenDuration, Enum.EasingStyle.Quad, Enum.EasingDirection.Out)
    local tween = TweenService:Create(self.Camera, tweenInfo, { FieldOfView = fov })
    tween:Play()

    return tween
end

-- Clean up camera controller
function CameraController:Cleanup()
    self:StopGameCamera()

    -- Reset camera to default
    self.Camera.CameraType = Enum.CameraType.Custom
    self.Camera.FieldOfView = 70

    if self.OriginalCFrame then
        self.Camera.CFrame = self.OriginalCFrame
    end

    print("[CameraController] Camera cleaned up")
end

return CameraController
]]></string>
          </Properties>
        </Item>
        <Item class="LocalScript" referent="52">
          <Properties>
            <string name="Name">EnhancedPlayerController</string>
            <string name="Source"><![CDATA[-- Enhanced PlayerController mit echter Position Updates und Forward Movement
--!strict

local Players = game:GetService("Players")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local RunService = game:GetService("RunService")
local TweenService = game:GetService("TweenService")
local UserInputService = game:GetService("UserInputService")

-- Sichere Module-Loading
local SharedFolder = ReplicatedStorage:WaitForChild("Shared", 10)
local GameConstants = if SharedFolder then require(SharedFolder:WaitForChild("GameConstants", 5)) else nil

-- Fallback für Game Constants
local function getLanePosition(lane: number): number
    if GameConstants and GameConstants.GetLanePosition then
        return GameConstants.GetLanePosition(lane)
    else
        -- Fallback zu eigener Lane-Berechnung
        return lane * 8 -- Standard lane width
    end
end

-- Enhanced PlayerController für echtes Subway Surfers Gameplay
local EnhancedPlayerController = {}
EnhancedPlayerController.__index = EnhancedPlayerController

-- Vollständige Typ Definitionen mit korrekten optional types
export type PlayerState = {
    lane: number,
    isJumping: boolean,
    isSliding: boolean,
    speed: number,
    distance: number,
    isGameActive: boolean,
}

-- EnhancedPlayerController Type mit allen Properties
type EnhancedPlayerControllerImpl = {
    player: Player,
    character: Model?,
    humanoid: Humanoid?,
    rootPart: BasePart?,
    state: PlayerState,
    forwardMovementConnection: RBXScriptConnection?,
    inputConnection: RBXScriptConnection?,
    movementTween: Tween?,

    -- Method signatures (self-referential)
    setupInputHandling: (EnhancedPlayerControllerImpl) -> (),
    startForwardMovement: (EnhancedPlayerControllerImpl) -> (),
    moveLeft: (EnhancedPlayerControllerImpl) -> (),
    moveRight: (EnhancedPlayerControllerImpl) -> (),
    animateToLane: (EnhancedPlayerControllerImpl) -> (),
    jump: (EnhancedPlayerControllerImpl) -> (),
    slide: (EnhancedPlayerControllerImpl) -> (),
    destroy: (EnhancedPlayerControllerImpl) -> (),
    pauseGame: (EnhancedPlayerControllerImpl) -> (),
    resumeGame: (EnhancedPlayerControllerImpl) -> (),
    resetGame: (EnhancedPlayerControllerImpl) -> (),
    initialize: (EnhancedPlayerControllerImpl) -> (),
    onCharacterAdded: (EnhancedPlayerControllerImpl, Model) -> (),
    sendPlayerAction: (EnhancedPlayerControllerImpl, string, any?) -> (),
    setupServerEvents: (EnhancedPlayerControllerImpl) -> (),
    handleGameStateChange: (EnhancedPlayerControllerImpl, string, any?) -> (),
    getDistance: (EnhancedPlayerControllerImpl) -> number,
    getSpeed: (EnhancedPlayerControllerImpl) -> number,
    getLane: (EnhancedPlayerControllerImpl) -> number,
    isActive: (EnhancedPlayerControllerImpl) -> boolean,
    setSpeed: (EnhancedPlayerControllerImpl, number) -> (),
    increaseSpeed: (EnhancedPlayerControllerImpl, number) -> (),
}

export type EnhancedPlayerController = EnhancedPlayerControllerImpl

-- Game Configuration
local CONFIG = {
    MOVEMENT_SPEED = 0.2, -- Lane switching speed
    FORWARD_SPEED = 25, -- Constant forward movement
    JUMP_HEIGHT = 20,
    JUMP_DURATION = 0.8,
    SLIDE_DURATION = 1.0,
    LANE_WIDTH = 8, -- Distance between lanes
}

function EnhancedPlayerController.new(): any
    local player = Players.LocalPlayer
    if not player then
        error("LocalPlayer not found")
    end

    local self = {
        player = player,
        character = nil :: Model?,
        humanoid = nil :: Humanoid?,
        rootPart = nil :: BasePart?,
        state = {
            lane = 0,
            isJumping = false,
            isSliding = false,
            speed = CONFIG.FORWARD_SPEED,
            distance = 0,
            isGameActive = true,
        } :: PlayerState,
        forwardMovementConnection = nil :: RBXScriptConnection?,
        inputConnection = nil :: RBXScriptConnection?,
        movementTween = nil :: Tween?,
    }
    setmetatable(self, EnhancedPlayerController)

    print("🎮 Enhanced PlayerController created - Subway Surfers ready!")
    return self
end

-- Bereinigung aller Verbindungen und Tweens
function EnhancedPlayerController:destroy()
    print("🧹 Bereinigung aller Verbindungen und Tweens")

    -- Stoppe alle aktiven Verbindungen - mit nil-checks
    local fmc = self.forwardMovementConnection
    if fmc then
        fmc:Disconnect()
        self.forwardMovementConnection = nil
    end

    local ic = self.inputConnection
    if ic then
        ic:Disconnect()
        self.inputConnection = nil
    end

    -- Stoppe alle aktiven Tweens - mit nil-checks
    local mt = self.movementTween
    if mt then
        mt:Cancel()
        self.movementTween = nil
    end
end

-- Input Handling für Bewegungssteuerung
function EnhancedPlayerController:setupInputHandling()
    self.inputConnection = UserInputService.InputBegan:Connect(function(input, gameProcessed)
        if gameProcessed or not self.state.isGameActive then
            return
        end

        if input.KeyCode == Enum.KeyCode.A or input.KeyCode == Enum.KeyCode.Left then
            self:moveLeft()
        elseif input.KeyCode == Enum.KeyCode.D or input.KeyCode == Enum.KeyCode.Right then
            self:moveRight()
        elseif
            input.KeyCode == Enum.KeyCode.W
            or input.KeyCode == Enum.KeyCode.Up
            or input.KeyCode == Enum.KeyCode.Space
        then
            self:jump()
        elseif input.KeyCode == Enum.KeyCode.S or input.KeyCode == Enum.KeyCode.Down then
            self:slide()
        end
    end)
end

-- Konstante Vorwärtsbewegung
function EnhancedPlayerController:startForwardMovement()
    if not self.rootPart then
        return
    end

    self.forwardMovementConnection = RunService.Heartbeat:Connect(function(deltaTime: number)
        if not self.state.isGameActive or not self.rootPart then
            return
        end

        -- Type-safe calculations mit expliziten Annotations
        local speed: number = self.state.speed
        local currentDistance: number = self.state.distance
        local moveDistance: number = speed * deltaTime
        self.state.distance = currentDistance + moveDistance

        -- Bewege Character vorwärts (Z-Achse in Roblox)
        local currentCFrame: CFrame = self.rootPart.CFrame
        local newPosition: Vector3 = currentCFrame.Position + Vector3.new(0, 0, moveDistance)
        self.rootPart.CFrame = CFrame.new(newPosition, newPosition + currentCFrame.LookVector)
    end)
end

-- Lane-basierte Bewegung (Links)
function EnhancedPlayerController:moveLeft()
    if self.state.lane > -1 then
        self.state.lane -= 1
        self:animateToLane()
    end
end

-- Lane-basierte Bewegung (Rechts)
function EnhancedPlayerController:moveRight()
    if self.state.lane < 1 then
        self.state.lane += 1
        self:animateToLane()
    end
end

-- Animiere zur Ziel-Lane mit GameConstants Integration
function EnhancedPlayerController:animateToLane()
    if not self.rootPart then
        return
    end

    -- Nutze getLanePosition für konsistente Lane-Positionen
    local targetX: number = getLanePosition(self.state.lane)
    local currentCFrame = self.rootPart.CFrame

    -- Stoppe vorherige Bewegung
    if self.movementTween then
        self.movementTween:Cancel()
    end

    -- Erstelle neuen Tween für sanfte Bewegung
    local tweenInfo = TweenInfo.new(CONFIG.MOVEMENT_SPEED, Enum.EasingStyle.Quad, Enum.EasingDirection.Out)
    self.movementTween = TweenService:Create(self.rootPart, tweenInfo, {
        CFrame = CFrame.new(targetX, currentCFrame.Position.Y, currentCFrame.Position.Z),
    })

    self.movementTween:Play()
    print("🏃 Lane-Wechsel zu Lane", self.state.lane, "X-Position:", targetX)
end

-- Sprung-Mechanik
function EnhancedPlayerController:jump()
    if self.state.isJumping or self.state.isSliding then
        return
    end
    if not self.rootPart or not self.humanoid then
        return
    end

    self.state.isJumping = true

    -- Erstelle Sprung-Animation
    local startY: number = self.rootPart.Position.Y
    local peakY: number = startY + CONFIG.JUMP_HEIGHT

    -- Aufwärts-Bewegung
    local jumpUpTween = TweenService:Create(
        self.rootPart,
        TweenInfo.new(CONFIG.JUMP_DURATION / 2, Enum.EasingStyle.Quad, Enum.EasingDirection.Out),
        { Position = Vector3.new(self.rootPart.Position.X, peakY, self.rootPart.Position.Z) }
    )

    -- Abwärts-Bewegung
    local jumpDownTween = TweenService:Create(
        self.rootPart,
        TweenInfo.new(CONFIG.JUMP_DURATION / 2, Enum.EasingStyle.Quad, Enum.EasingDirection.In),
        { Position = Vector3.new(self.rootPart.Position.X, startY, self.rootPart.Position.Z) }
    )

    -- Spiele Sprung-Sequenz ab
    jumpUpTween:Play()
    jumpUpTween.Completed:Connect(function()
        jumpDownTween:Play()
        jumpDownTween.Completed:Connect(function()
            self.state.isJumping = false
        end)
    end)
end

-- Rutsch-Mechanik
function EnhancedPlayerController:slide()
    if self.state.isJumping or self.state.isSliding then
        return
    end
    if not self.humanoid then
        return
    end

    self.state.isSliding = true

    -- Verändere Character-Größe für Rutsch-Effekt (verkleinerung der hitbox)
    local originalSize: number = self.humanoid.HipHeight
    self.humanoid.HipHeight = originalSize * 0.5

    -- Nach Slide-Duration zurücksetzen
    wait(CONFIG.SLIDE_DURATION)

    if self.humanoid then
        self.humanoid.HipHeight = originalSize
    end
    self.state.isSliding = false
end

-- Geschwindigkeits-Management
function EnhancedPlayerController:setSpeed(newSpeed: number)
    self.state.speed = math.max(0, newSpeed)
end

function EnhancedPlayerController:increaseSpeed(amount: number)
    local currentSpeed: number = self.state.speed
    self.state.speed = currentSpeed + amount
end

-- Game State Management
function EnhancedPlayerController:pauseGame()
    self.state.isGameActive = false
end

function EnhancedPlayerController:resumeGame()
    self.state.isGameActive = true
end

function EnhancedPlayerController:resetGame()
    self.state.distance = 0
    self.state.speed = CONFIG.FORWARD_SPEED
    self.state.lane = 0
    self.state.isJumping = false
    self.state.isSliding = false
    self.state.isGameActive = true

    -- Resetze Position zur Mitte
    if self.rootPart then
        local currentPos = self.rootPart.Position
        self.rootPart.CFrame = CFrame.new(0, currentPos.Y, currentPos.Z)
    end
end

-- Getter für Game State
function EnhancedPlayerController:getDistance(): number
    return self.state.distance
end

function EnhancedPlayerController:getSpeed(): number
    return self.state.speed
end

function EnhancedPlayerController:getLane(): number
    return self.state.lane
end

function EnhancedPlayerController:isActive(): boolean
    return self.state.isGameActive
end

-- Character Event Handling
function EnhancedPlayerController:onCharacterAdded(character: Model)
    self.character = character
    self.humanoid = character:WaitForChild("Humanoid") :: Humanoid
    self.rootPart = character:WaitForChild("HumanoidRootPart") :: BasePart

    -- Restart forward movement mit neuem Character
    if self.forwardMovementConnection then
        self.forwardMovementConnection:Disconnect()
    end
    self:startForwardMovement()
end

-- Server Communication mit verbesserter Fehlerbehandlung
function EnhancedPlayerController:sendPlayerAction(action: string, data: any?)
    local success = pcall(function()
        local RemoteEvents = ReplicatedStorage:WaitForChild("RemoteEvents", 5)
        if not RemoteEvents then
            warn("⚠️ RemoteEvents nicht gefunden!")
            return
        end

        local PlayerActionEvent = RemoteEvents:WaitForChild("PlayerAction", 5)
        if PlayerActionEvent then
            PlayerActionEvent:FireServer(action, data)
            print("📤 PlayerAction gesendet:", action)
        end
    end)

    if not success then
        warn("❌ Fehler bei Server-Kommunikation:", action)
    end
end

-- Game State Events Integration
function EnhancedPlayerController:setupServerEvents()
    local success = pcall(function()
        local RemoteEvents = ReplicatedStorage:WaitForChild("RemoteEvents", 10)
        if not RemoteEvents then
            return
        end

        -- GameStateChanged Event
        local GameStateChangedEvent = RemoteEvents:WaitForChild("GameStateChanged", 5)
        if GameStateChangedEvent then
            GameStateChangedEvent.OnClientEvent:Connect(function(newState, data)
                self:handleGameStateChange(newState, data)
            end)
        end

        -- ScoreUpdate Event
        local ScoreUpdateEvent = RemoteEvents:WaitForChild("ScoreUpdate", 5)
        if ScoreUpdateEvent then
            ScoreUpdateEvent.OnClientEvent:Connect(function(newScore, itemType)
                print("🎯 Score Update:", newScore, "von", itemType or "unbekannt")
            end)
        end
    end)

    if not success then
        warn("❌ Fehler beim Setup der Server-Events")
    end
end

-- Game State Change Handler
function EnhancedPlayerController:handleGameStateChange(newState: string, data: any?)
    print("🎮 Server Game State:", newState)

    if newState == "Playing" then
        if not self.state.isGameActive then
            self:resumeGame()
        end
    elseif newState == "Menu" then
        if self.state.isGameActive then
            self:pauseGame()
        end
    elseif newState == "GameOver" then
        self:pauseGame()
        print("💀 Game Over! Final Score:", data and data.finalScore or "Unbekannt")

        -- Auto-restart nach Delay
        task.wait(3)
        self:resetGame()
    end
end

-- Initialisiere PlayerController mit Server-Integration
function EnhancedPlayerController:initialize()
    -- Setup Character Change Detection
    self.player.CharacterAdded:Connect(function(character: Model)
        self:onCharacterAdded(character)
    end)

    -- Handle Character mit nil-safe handling
    local currentCharacter = self.player.Character
    if currentCharacter then
        task.spawn(function()
            self:onCharacterAdded(currentCharacter)
        end)
    end

    -- Setup Server Events
    self:setupServerEvents()

    print("✅ Enhanced PlayerController vollständig initialisiert!")
end

-- Auto-initialisierung
local playerController = EnhancedPlayerController.new()
playerController:initialize()

print("🎮 ENHANCED SUBWAY SURFERS CONTROLLER AKTIV!")
print("🎯 WASD/Pfeiltasten = Bewegung | Space/W = Sprung | S = Rutsch")

return EnhancedPlayerController
]]></string>
          </Properties>
        </Item>
        <Item class="LocalScript" referent="53">
          <Properties>
            <string name="Name">PlayerController</string>
            <string name="Source"><![CDATA[-- PlayerController.client.lua - Main client-side player movement and game control
local Players = game:GetService("Players")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local RunService = game:GetService("RunService")
local TweenService = game:GetService("TweenService")
local UserInputService = game:GetService("UserInputService")

local player = Players.LocalPlayer

-- Wait for essential modules with proper error handling
local SubwaySurfersGameplay
local gameModulesReady = false

spawn(function()
	print("🔄 Waiting for game modules...")

	-- Load from correct Rojo path structure
	local success, result = pcall(function()
		-- Wait for Shared folder first
		local sharedFolder = ReplicatedStorage:WaitForChild("Shared", 30)
		if not sharedFolder then
			error("Shared folder not found in ReplicatedStorage")
		end

		-- Load SubwaySurfersGameplay module
		local gameplayModule = sharedFolder:WaitForChild("SubwaySurfersGameplay", 15)
		if not gameplayModule then
			error("SubwaySurfersGameplay module not found in Shared folder")
		end

		return require(gameplayModule)
	end)

	if success then
		SubwaySurfersGameplay = result
		print("✅ SubwaySurfersGameplay loaded successfully from ReplicatedStorage.Shared")
		gameModulesReady = true
		print("✅ All game modules loaded successfully")
	else
		warn("❌ Failed to load SubwaySurfersGameplay:", result)
		error("❌ Could not load SubwaySurfersGameplay: " .. tostring(result))
	end
end)

print("🎮 SUBWAY SURFERS PLAYER CONTROLLER ACTIVE")

-- Game state
local gameActive = false
local CURRENT_LANE = 0 -- Start in center lane (-1=left, 0=center, 1=right)
local MOVE_SPEED = 0.3 -- Lane switching speed
local START_COOLDOWN = 5.0 -- Increased cooldown between game starts
local lastStartTime = 0

-- Character references
local character = player.CharacterAdded:Wait()
local humanoid = character:WaitForChild("Humanoid")
local rootPart = character:WaitForChild("HumanoidRootPart")

-- Position player at starting position
local startPosition = Vector3.new(0, 5, 0) -- Center of track, slightly above ground
rootPart.CFrame = CFrame.lookAt(startPosition, startPosition + Vector3.new(0, 0, 100))

print("🎮 Player positioned at:", rootPart.Position.X, rootPart.Position.Y, rootPart.Position.Z)
print(
	"🎮 Player facing direction:",
	rootPart.CFrame.LookVector.X,
	rootPart.CFrame.LookVector.Y,
	rootPart.CFrame.LookVector.Z
)
print("🎮 Should be facing positive Z (forward toward track)")

-- Camera following setup
local camera = workspace.CurrentCamera
local cameraConnection
local CAMERA_OFFSET = Vector3.new(0, 8, -12) -- Behind and above player

local function startCameraFollow()
	if cameraConnection then
		cameraConnection:Disconnect()
	end

	camera.CameraType = Enum.CameraType.Scriptable

	cameraConnection = RunService.Heartbeat:Connect(function()
		if gameActive and character and rootPart then
			-- Camera follows behind player facing the same direction
			local cameraPosition = rootPart.Position + CAMERA_OFFSET
			camera.CFrame = CFrame.lookAt(cameraPosition, rootPart.Position + rootPart.CFrame.LookVector * 10)
		end
	end)

	print("🎥 Game camera setup complete - following player for correct orientation")
end

local function stopCameraFollow()
	if cameraConnection then
		cameraConnection:Disconnect()
		cameraConnection = nil
	end
	camera.CameraType = Enum.CameraType.Custom
	print("🎥 Camera following stopped")
end

-- Movement functions
local function switchLane(direction)
	if not gameActive then
		return
	end

	-- Calculate new lane
	local newLane = CURRENT_LANE + direction
	if newLane < -1 or newLane > 1 then
		return
	end -- Stay within bounds

	CURRENT_LANE = newLane

	-- Get target position
	local targetX = SubwaySurfersGameplay.GetLanePosition(CURRENT_LANE)
	local currentCFrame = rootPart.CFrame
	local targetCFrame = CFrame.new(
		Vector3.new(targetX, currentCFrame.Position.Y, currentCFrame.Position.Z),
		currentCFrame.Position + currentCFrame.LookVector
	)

	-- Smooth lane switching animation
	local moveInfo = TweenInfo.new(MOVE_SPEED, Enum.EasingStyle.Quad)
	local moveTween = TweenService:Create(rootPart, moveInfo, { CFrame = targetCFrame })
	moveTween:Play()

	print("🏃 LANE SWITCH to", CURRENT_LANE, "X:", targetX)
end

local function jump()
	if not gameActive then
		return
	end

	-- Simple jump - prevent multiple jumps
	if humanoid.FloorMaterial == Enum.Material.Air then
		return
	end -- Already jumping

	humanoid:ChangeState(Enum.HumanoidStateType.Jumping)
	print("🏃 JUMP!")
end

local function slide()
	if not gameActive then
		return
	end

	-- Ensure player is on ground for sliding
	if humanoid.FloorMaterial == Enum.Material.Air then
		return
	end

	-- Improved slide animation - crouch down for longer duration with collision detection
	local originalCFrame = rootPart.CFrame
	local slideCFrame = originalCFrame * CFrame.new(0, -2, 0)

	-- Create temporary slide hitbox (smaller than player)
	local slideHitbox = Instance.new("Part")
	slideHitbox.Name = "SlideHitbox"
	slideHitbox.Size = Vector3.new(2, 1, 2) -- Lower profile hitbox
	slideHitbox.Transparency = 1
	slideHitbox.CanCollide = false
	slideHitbox.Anchored = true
	slideHitbox.Parent = character
	slideHitbox.CFrame = rootPart.CFrame * CFrame.new(0, -1.5, 0)

	local slideInfo = TweenInfo.new(0.3, Enum.EasingStyle.Quad)
	local slideDown = TweenService:Create(rootPart, slideInfo, { CFrame = slideCFrame })
	local slideUp = TweenService:Create(rootPart, slideInfo, { CFrame = originalCFrame })

	slideDown:Play()
	slideDown.Completed:Connect(function()
		-- Update hitbox position during slide
		slideHitbox.CFrame = rootPart.CFrame * CFrame.new(0, -1.5, 0)

		task.wait(0.6) -- Stay in slide position
		slideUp:Play()
		slideUp.Completed:Connect(function()
			slideHitbox:Destroy() -- Clean up slide hitbox
		end)
	end)

	print("🏃 SLIDE!")
end

-- Updated server readiness check
local function isServerFullyReady()
	-- Check if modules are loaded
	if not gameModulesReady then
		warn("⚠️ Game modules not ready yet")
		return false
	end

	-- Check server ready signals
	local serverReady = ReplicatedStorage:FindFirstChild("ServerReady")
	local gameManagerReady = ReplicatedStorage:FindFirstChild("GameManagerReady")

	if not serverReady or not serverReady.Value then
		warn("⚠️ Server not ready")
		return false
	end

	if not gameManagerReady or not gameManagerReady.Value then
		warn("⚠️ GameManager not ready")
		return false
	end

	-- Check RemoteFunctions availability
	local RemoteFunctions = ReplicatedStorage:FindFirstChild("RemoteFunctions")
	if not RemoteFunctions then
		warn("⚠️ RemoteFunctions not available")
		return false
	end

	local GetServerStatus = RemoteFunctions:FindFirstChild("GetServerStatus")
	if not GetServerStatus then
		warn("⚠️ GetServerStatus function not available")
		return false
	end

	-- Try to call server status
	local success, status = pcall(function()
		return GetServerStatus:InvokeServer()
	end)

	if not success or not status or not status.ready then
		warn("⚠️ Server status check failed or server not ready")
		return false
	end

	return true
end

local startGame -- Forward declaration
startGame = function()
	print("[WorkingPlayerController] startGame() called")

	-- Wait for modules to be ready
	if not gameModulesReady then
		print("[WorkingPlayerController] Waiting for game modules...")
		while not gameModulesReady do
			task.wait(0.1)
		end
	end

	-- Debounce to prevent multiple rapid starts
	local currentTime = tick()
	if currentTime - lastStartTime < START_COOLDOWN then
		print("[WorkingPlayerController] Start game cooldown active, ignoring")
		return
	end
	lastStartTime = currentTime

	if gameActive then
		print("[WorkingPlayerController] Game already active, ignoring")
		return
	end -- Already active

	-- Comprehensive server readiness check
	if not isServerFullyReady() then
		warn("[WorkingPlayerController] Server not fully ready - deferring game start")
		task.wait(2.0)
		print("[WorkingPlayerController] Retrying game start after server check...")
		startGame()
		return
	end

	print("[WorkingPlayerController] Server confirmed fully ready - starting game...")
	gameActive = true

	-- Use SubwaySurfersGameplay safely
	if SubwaySurfersGameplay and SubwaySurfersGameplay.GetLanePosition then
		rootPart.CFrame = CFrame.lookAt(
			Vector3.new(SubwaySurfersGameplay.GetLanePosition(CURRENT_LANE), rootPart.Position.Y, rootPart.Position.Z),
			Vector3.new(
				SubwaySurfersGameplay.GetLanePosition(CURRENT_LANE),
				rootPart.Position.Y,
				rootPart.Position.Z + 100
			)
		)
		print(
			"🎯 Game started: Player locked to lane",
			CURRENT_LANE,
			"X position:",
			SubwaySurfersGameplay.GetLanePosition(CURRENT_LANE)
		)
	else
		warn("⚠️ SubwaySurfersGameplay not available, using fallback positioning")
		rootPart.CFrame = CFrame.lookAt(
			Vector3.new(0, rootPart.Position.Y, rootPart.Position.Z),
			Vector3.new(0, rootPart.Position.Y, rootPart.Position.Z + 100)
		)
	end

	-- Send start game action to server with error handling
	local success, err = pcall(function()
		local RemoteEvents = ReplicatedStorage:WaitForChild("RemoteEvents", 5)
		local PlayerActionEvent = RemoteEvents:WaitForChild("PlayerAction", 5)
		PlayerActionEvent:FireServer("StartGame", { timestamp = tick() })
	end)

	if success then
		print("[WorkingPlayerController] Sending StartGame action to server")
	else
		warn("[WorkingPlayerController] Failed to send StartGame action:", err)
	end

	print("🎮 GAME STARTED! Use WASD or Arrow Keys to move")

	-- Start camera following
	startCameraFollow()
end

local function stopGame()
	print("[WorkingPlayerController] stopGame() called")
	gameActive = false
	print("🛑 GAME STOPPED")

	-- Stop camera following
	stopCameraFollow()

	-- Send end game action to server
	local RemoteEvents = ReplicatedStorage:WaitForChild("RemoteEvents")
	if RemoteEvents then
		local PlayerActionEvent = RemoteEvents:WaitForChild("PlayerAction")
		if PlayerActionEvent then
			PlayerActionEvent:FireServer("EndGame", { timestamp = tick(), reason = "Manual stop" })
		end
	end

	-- Reset player position to starting position
	CURRENT_LANE = 0
	rootPart.CFrame = CFrame.lookAt(
		Vector3.new(SubwaySurfersGameplay.GetLanePosition(CURRENT_LANE), 5, 0),
		Vector3.new(SubwaySurfersGameplay.GetLanePosition(CURRENT_LANE), 5, 100)
	)
	print("🎯 Player reset to center lane facing forward")
end

-- Input handling
UserInputService.InputBegan:Connect(function(input, gameProcessed)
	if gameProcessed then
		return
	end

	-- Game control inputs (always available)
	if input.KeyCode == Enum.KeyCode.R then
		if gameActive then
			stopGame()
		else
			startGame()
		end
	end

	-- Movement inputs (only when game is active)
	if not gameActive then
		return
	end

	if input.KeyCode == Enum.KeyCode.A or input.KeyCode == Enum.KeyCode.Left then
		switchLane(-1) -- Move left
	elseif input.KeyCode == Enum.KeyCode.D or input.KeyCode == Enum.KeyCode.Right then
		switchLane(1) -- Move right
	elseif
		input.KeyCode == Enum.KeyCode.W
		or input.KeyCode == Enum.KeyCode.Up
		or input.KeyCode == Enum.KeyCode.Space
	then
		jump()
	elseif input.KeyCode == Enum.KeyCode.S or input.KeyCode == Enum.KeyCode.Down then
		slide()
	end
end)

-- Handle game state changes from server
local function onGameStateChanged(newState, data)
	print("[WorkingPlayerController] Server game state changed to:", newState)

	if newState == "Playing" then
		if not gameActive then
			gameActive = true
			startCameraFollow()
			print("[WorkingPlayerController] Server confirmed game started")
		end
	elseif newState == "Menu" then
		if gameActive then
			print("[WorkingPlayerController] Server says back to menu")
			stopGame()
		end
	elseif newState == "GameOver" then
		if gameActive then
			gameActive = false
			stopCameraFollow()
			print("[WorkingPlayerController] Game over - Final score:", data and data.finalScore or "Unknown")

			-- Auto restart after a delay
			task.wait(5) -- Increased delay
			print("[WorkingPlayerController] Auto-restarting game...")
			startGame()
		end
	end
end

-- Wait for server to be ready before starting game
local function waitForServerReady()
	print("🎮 WAITING FOR SERVER TO BE READY...")

	-- Wait for both server ready signals with longer timeout
	local serverReady = ReplicatedStorage:WaitForChild("ServerReady", 45) -- 45 second timeout
	if not serverReady then
		warn("🎮 ⚠️ Server ready signal not received - starting anyway")
		return
	end

	local gameManagerReady = ReplicatedStorage:WaitForChild("GameManagerReady", 15) -- 15 second timeout
	if not gameManagerReady then
		warn("🎮 ⚠️ GameManager ready signal not received - starting anyway")
	end

	-- Wait for both to be true
	local function checkBothReady()
		return serverReady.Value and (not gameManagerReady or gameManagerReady.Value)
	end

	if checkBothReady() then
		print("🎮 ✅ SERVER IS READY!")
		print("🎮 ⏳ Waiting for player initialization...")
		print("🎮 Auto-starting in 8 seconds to ensure proper initialization...")
		task.wait(8.0) -- Extended delay to ensure server has fully initialized player
		print("🎮 AUTO-STARTING SUBWAY SURFERS!")
		print("🎮 No need to press R - the game starts automatically!")
		startGame()
	else
		-- Server not ready yet, wait for value change
		print("🎮 ⏳ Server initializing... waiting for ready signal...")

		local function onReadyChanged()
			if checkBothReady() then
				print("🎮 ✅ SERVER IS NOW READY!")
				print("🎮 ⏳ Waiting for player initialization...")
				print("🎮 Auto-starting in 8 seconds to ensure proper initialization...")
				task.wait(8.0) -- Extended delay to ensure server has fully initialized player
				print("🎮 AUTO-STARTING SUBWAY SURFERS!")
				print("🎮 No need to press R - the game starts automatically!")
				startGame()
			end
		end

		serverReady.Changed:Connect(onReadyChanged)
		if gameManagerReady then
			gameManagerReady.Changed:Connect(onReadyChanged)
		end
	end
end

-- Connect to server events
task.spawn(function()
	local RemoteEvents = ReplicatedStorage:WaitForChild("RemoteEvents", 15) -- Increased timeout
	if RemoteEvents then
		local GameStateChangedEvent = RemoteEvents:WaitForChild("GameStateChanged", 10)
		if GameStateChangedEvent then
			GameStateChangedEvent.OnClientEvent:Connect(onGameStateChanged)
			print("🎮 Connected to server game state events")
		end

		local ScoreUpdateEvent = RemoteEvents:WaitForChild("ScoreUpdate", 10)
		if ScoreUpdateEvent then
			ScoreUpdateEvent.OnClientEvent:Connect(function(newScore, itemType)
				print("🎯 Score updated:", newScore, "from", itemType or "unknown")
			end)
		end
	end
end)

-- Handle character respawning
player.CharacterAdded:Connect(function(newCharacter)
	character = newCharacter
	humanoid = character:WaitForChild("Humanoid")
	rootPart = character:WaitForChild("HumanoidRootPart")

	-- Reset position and state
	task.wait(0.1) -- Wait for character to fully load
	rootPart.CFrame = CFrame.lookAt(Vector3.new(0, 5, 0), Vector3.new(0, 5, 100))

	gameActive = false
	CURRENT_LANE = 0

	print("🎮 Character respawned - ready for new game")
end)

-- Initialize
task.spawn(function()
	-- Give the server more time to initialize
	task.wait(5.0) -- Increased initial delay
	waitForServerReady()
end)

-- Status display
task.spawn(function()
	task.wait(8) -- Increased delay
	print("✅ SUBWAY SURFERS READY!")
	print("✅ Game will start automatically!")
	print("✅ Use WASD or Arrow Keys to move")
	print("✅ Space/W = Jump, S = Slide")
	print("✅ Collect yellow coins and blue power-ups")
	print("✅ Avoid red trains!")
	print("🎯 LANE SYSTEM: Left(-8), Center(0), Right(8)")
	print("🎯 LANES: A/Left = Move Left, D/Right = Move Right")
	print("🎯 ORIENTATION: Player faces positive Z, camera follows behind")
	print("🎥 CAMERA FIX: Movement should now match visual direction!")
end)
]]></string>
          </Properties>
        </Item>
      </Item>
      <Item class="Folder" referent="54">
        <Properties>
          <string name="Name">modules</string>
        </Properties>
        <Item class="ModuleScript" referent="55">
          <Properties>
            <string name="Name">AudioController</string>
            <string name="Source"><![CDATA[--!strict
-- AudioController.lua - Audio system for Subway Surfers
local SoundService = game:GetService("SoundService")
local TweenService = game:GetService("TweenService")
local _ReplicatedStorage = game:GetService("ReplicatedStorage")

local AudioController = {}

-- Type definitions
type SoundInstance = {
    sound: Sound,
    originalVolume: number,
    isPlaying: boolean,
}

-- Audio configuration
local AUDIO_CONFIG = {
    masterVolume = 0.8,
    musicVolume = 0.6,
    sfxVolume = 0.7,
    fadeTime = 1.0,
}

-- Sound storage
local sounds: { [string]: SoundInstance } = {}
local currentMusic: Sound? = nil

-- Sound effect IDs (placeholders - replace with actual Roblox audio IDs)
local SOUND_IDS = {
    -- Music
    menu_music = "rbxasset://sounds/electronicpingshort.wav",
    game_music = "rbxasset://sounds/impact_water.mp3",

    -- Sound Effects
    coin_collect = "rbxasset://sounds/button.wav",
    gem_collect = "rbxasset://sounds/switch.wav",
    power_up_collect = "rbxasset://sounds/hit.wav",
    power_up_activate = "rbxasset://sounds/woosh.wav",
    jump = "rbxasset://sounds/footsteps/concrete1.mp3",
    obstacle_hit = "rbxasset://sounds/impact_water.mp3",
    lane_switch = "rbxasset://sounds/footsteps/grass1.mp3",
    speed_boost = "rbxasset://sounds/jet_engine.wav",
}

-- Initialize audio controller
function AudioController:Initialize()
    -- Create sound group for better organization
    local soundGroup = Instance.new("SoundGroup")
    soundGroup.Name = "SubwaySurfers"
    soundGroup.Volume = AUDIO_CONFIG.masterVolume
    soundGroup.Parent = SoundService

    -- Create sound instances
    self:CreateSounds(soundGroup)

    print("[AudioController] Audio system initialized")
end

-- Create all sound instances
function AudioController:CreateSounds(soundGroup: SoundGroup)
    for soundName, soundId in pairs(SOUND_IDS) do
        local sound = Instance.new("Sound")
        sound.Name = soundName
        sound.SoundId = soundId
        sound.SoundGroup = soundGroup

        -- Set volume based on type
        if string.find(soundName, "music") then
            sound.Volume = AUDIO_CONFIG.musicVolume
        else
            sound.Volume = AUDIO_CONFIG.sfxVolume
        end

        -- Set looping for music
        if string.find(soundName, "music") then
            sound.Looped = true
        end

        sound.Parent = SoundService

        -- Store sound instance
        sounds[soundName] = {
            sound = sound,
            originalVolume = sound.Volume,
            isPlaying = false,
        }
    end
end

-- Play sound effect
function AudioController:PlaySFX(soundName: string, volume: number?)
    local soundInstance = sounds[soundName]
    if not soundInstance then
        warn("[AudioController] Sound not found:", soundName)
        return
    end

    local sound = soundInstance.sound

    -- Set volume if specified
    if volume then
        sound.Volume = volume * AUDIO_CONFIG.sfxVolume
    else
        sound.Volume = soundInstance.originalVolume
    end

    -- Play sound
    sound:Play()

    -- Mark as playing
    soundInstance.isPlaying = true

    -- Reset playing flag when finished
    sound.Ended:Connect(function()
        soundInstance.isPlaying = false
    end)
end

-- Play background music
function AudioController:PlayMusic(musicName: string, fadeIn: boolean?)
    local soundInstance = sounds[musicName]
    if not soundInstance then
        warn("[AudioController] Music not found:", musicName)
        return
    end

    local sound = soundInstance.sound

    -- Stop current music
    if currentMusic and currentMusic.IsPlaying then
        self:StopMusic(true) -- Fade out current music
    end

    -- Set as current music
    currentMusic = sound
    soundInstance.isPlaying = true

    if fadeIn then
        -- Start with zero volume and fade in
        sound.Volume = 0
        sound:Play()

        local tweenInfo = TweenInfo.new(AUDIO_CONFIG.fadeTime, Enum.EasingStyle.Quad, Enum.EasingDirection.Out)
        local tween = TweenService:Create(sound, tweenInfo, { Volume = soundInstance.originalVolume })
        tween:Play()
    else
        -- Play immediately at full volume
        sound.Volume = soundInstance.originalVolume
        sound:Play()
    end

    print("[AudioController] Playing music:", musicName)
end

-- Stop background music
function AudioController:StopMusic(fadeOut: boolean?)
    if not currentMusic then
        return
    end

    local sound = currentMusic

    if fadeOut then
        -- Fade out and stop
        local tweenInfo = TweenInfo.new(AUDIO_CONFIG.fadeTime, Enum.EasingStyle.Quad, Enum.EasingDirection.Out)
        local tween = TweenService:Create(sound, tweenInfo, { Volume = 0 })
        tween:Play()

        tween.Completed:Connect(function()
            sound:Stop()
            sound.Volume = sounds[sound.Name].originalVolume -- Reset volume
        end)
    else
        -- Stop immediately
        sound:Stop()
    end

    -- Update playing flag
    if sounds[sound.Name] then
        sounds[sound.Name].isPlaying = false
    end

    currentMusic = nil
    print("[AudioController] Stopped music")
end

-- Set master volume
function AudioController:SetMasterVolume(volume: number)
    AUDIO_CONFIG.masterVolume = math.clamp(volume, 0, 1)

    local soundGroup = SoundService:FindFirstChild("SubwaySurfers") :: SoundGroup?
    if soundGroup then
        soundGroup.Volume = AUDIO_CONFIG.masterVolume
    end
end

-- Set music volume
function AudioController:SetMusicVolume(volume: number)
    AUDIO_CONFIG.musicVolume = math.clamp(volume, 0, 1)

    -- Update all music sounds
    for soundName, soundInstance in pairs(sounds) do
        if string.find(soundName, "music") then
            soundInstance.originalVolume = AUDIO_CONFIG.musicVolume
            if soundInstance.isPlaying then
                soundInstance.sound.Volume = AUDIO_CONFIG.musicVolume
            end
        end
    end
end

-- Set SFX volume
function AudioController:SetSFXVolume(volume: number)
    AUDIO_CONFIG.sfxVolume = math.clamp(volume, 0, 1)

    -- Update all SFX sounds
    for soundName, soundInstance in pairs(sounds) do
        if not string.find(soundName, "music") then
            soundInstance.originalVolume = AUDIO_CONFIG.sfxVolume
        end
    end
end

-- Convenient methods for common sounds
function AudioController:PlayCoinCollect()
    self:PlaySFX("coin_collect", 0.8)
end

function AudioController:PlayGemCollect()
    self:PlaySFX("gem_collect", 0.9)
end

function AudioController:PlayPowerUpCollect()
    self:PlaySFX("power_up_collect", 1.0)
end

function AudioController:PlayPowerUpActivate()
    self:PlaySFX("power_up_activate", 0.9)
end

function AudioController:PlayJump()
    self:PlaySFX("jump", 0.6)
end

function AudioController:PlayObstacleHit()
    self:PlaySFX("obstacle_hit", 1.0)
end

function AudioController:PlayLaneSwitch()
    self:PlaySFX("lane_switch", 0.4)
end

function AudioController:PlaySpeedBoost()
    self:PlaySFX("speed_boost", 0.7)
end

-- Play menu music
function AudioController:PlayMenuMusic()
    self:PlayMusic("menu_music", true)
end

-- Play game music
function AudioController:PlayGameMusic()
    self:PlayMusic("game_music", true)
end

-- Get audio settings for UI
function AudioController:GetAudioSettings()
    return {
        masterVolume = AUDIO_CONFIG.masterVolume,
        musicVolume = AUDIO_CONFIG.musicVolume,
        sfxVolume = AUDIO_CONFIG.sfxVolume,
    }
end

-- Load audio settings
function AudioController:LoadAudioSettings(settings: { [string]: number })
    if settings.masterVolume then
        self:SetMasterVolume(settings.masterVolume)
    end
    if settings.musicVolume then
        self:SetMusicVolume(settings.musicVolume)
    end
    if settings.sfxVolume then
        self:SetSFXVolume(settings.sfxVolume)
    end
end

-- Cleanup audio system
function AudioController:Cleanup()
    -- Stop all sounds
    for _, soundInstance in pairs(sounds) do
        soundInstance.sound:Stop()
        soundInstance.sound:Destroy()
    end

    -- Clear storage
    table.clear(sounds)
    currentMusic = nil

    -- Remove sound group
    local soundGroup = SoundService:FindFirstChild("SubwaySurfers")
    if soundGroup then
        soundGroup:Destroy()
    end

    print("[AudioController] Audio system cleaned up")
end

return AudioController
]]></string>
          </Properties>
        </Item>
        <Item class="ModuleScript" referent="56">
          <Properties>
            <string name="Name">EffectsController</string>
            <string name="Source"><![CDATA[--!strict
-- EffectsController.lua - Visual effects system for Subway Surfers
local Debris = game:GetService("Debris")
local RunService = game:GetService("RunService")
local TweenService = game:GetService("TweenService")
local _ReplicatedStorage = game:GetService("ReplicatedStorage")

-- Note: ObjectPool will be loaded when needed to avoid circular dependency

local EffectsController = {}

-- Type definitions
type Effect = {
    part: BasePart,
    tween: Tween?,
    connection: RBXScriptConnection?,
    startTime: number,
    duration: number,
}

type EffectConfig = {
    size: Vector3,
    color: Color3,
    material: Enum.Material,
    duration: number,
    scaleMultiplier: number?,
    count: number?,
}

-- Active effects tracking
local activeEffects: { Effect } = {}

-- Effect configurations
local EFFECT_CONFIGS: { [string]: EffectConfig } = {
    coin_collect = {
        size = Vector3.new(2, 2, 0.1),
        color = Color3.fromRGB(255, 215, 0),
        material = Enum.Material.Neon,
        duration = 1.5,
        scaleMultiplier = 3,
    },
    gem_collect = {
        size = Vector3.new(1.5, 1.5, 0.1),
        color = Color3.fromRGB(138, 43, 226),
        material = Enum.Material.ForceField,
        duration = 2,
        scaleMultiplier = 4,
    },
    power_up = {
        size = Vector3.new(3, 3, 0.1),
        color = Color3.fromRGB(0, 255, 255),
        material = Enum.Material.Neon,
        duration = 2.5,
        scaleMultiplier = 5,
    },
    speed_lines = {
        size = Vector3.new(0.5, 0.5, 15),
        color = Color3.fromRGB(255, 255, 255),
        material = Enum.Material.Neon,
        duration = 0.3,
        count = 8,
    },
    explosion = {
        size = Vector3.new(5, 5, 5),
        color = Color3.fromRGB(255, 100, 0),
        material = Enum.Material.Neon,
        duration = 1,
        scaleMultiplier = 3,
    },
}

-- Initialize effects controller
function EffectsController:Initialize()
    -- Cleanup loop for active effects
    RunService.Heartbeat:Connect(function()
        self:UpdateActiveEffects()
    end)

    print("[EffectsController] Visual effects system initialized")
end

-- Create a new effect part
function EffectsController:CreateEffectPart(effectName: string, config: EffectConfig): BasePart
    local part = Instance.new("Part")
    part.Name = effectName .. "_effect"
    part.Size = config.size
    part.Color = config.color
    part.Material = config.material
    part.Anchored = true
    part.CanCollide = false
    part.TopSurface = Enum.SurfaceType.Smooth
    part.BottomSurface = Enum.SurfaceType.Smooth

    return part
end

-- Play collectible collection effect
function EffectsController:PlayCollectibleEffect(position: Vector3, collectibleType: string)
    local effectType = "coin_collect"
    if collectibleType == "GEM" then
        effectType = "gem_collect"
    elseif collectibleType == "KEY" or collectibleType == "MYSTERY_BOX" then
        effectType = "power_up"
    end

    local config = EFFECT_CONFIGS[effectType]
    if not config then
        return
    end

    local effectPart = self:CreateEffectPart(effectType, config)

    -- Position the effect
    effectPart.CFrame = CFrame.new(position)
    effectPart.Parent = workspace

    -- Create collection animation
    local scaleMultiplier = config.scaleMultiplier or 2
    local targetSize = effectPart.Size * scaleMultiplier
    local endPosition = position + Vector3.new(0, 10, 0)

    -- Scale and fade animation
    local tweenInfo = TweenInfo.new(config.duration, Enum.EasingStyle.Quad, Enum.EasingDirection.Out)

    local scaleTween = TweenService:Create(effectPart, tweenInfo, {
        Size = targetSize,
        Transparency = 1,
        CFrame = CFrame.new(endPosition),
    })

    scaleTween:Play()

    -- Store effect for cleanup
    local effect: Effect = {
        part = effectPart,
        tween = scaleTween,
        connection = nil,
        startTime = tick(),
        duration = config.duration,
    }

    table.insert(activeEffects, effect)

    -- Cleanup when done
    scaleTween.Completed:Connect(function()
        effectPart:Destroy()
        self:RemoveActiveEffect(effect)
    end)
end

-- Play speed boost effect
function EffectsController:PlaySpeedEffect(rootPart: BasePart, isActive: boolean)
    if not rootPart then
        return
    end

    if isActive then
        -- Create speed lines effect
        local config = EFFECT_CONFIGS.speed_lines

        for i = 1, config.count do
            local speedLine = Instance.new("Part")
            speedLine.Name = "SpeedLine"
            speedLine.Size = config.size
            speedLine.Color = config.color
            speedLine.Material = config.material
            speedLine.Anchored = true
            speedLine.CanCollide = false
            speedLine.Transparency = 0.5

            -- Random position around player
            local angle = (i / config.count) * math.pi * 2
            local radius = 8
            local offset = Vector3.new(math.cos(angle) * radius, math.random(-2, 2), math.sin(angle) * radius)

            speedLine.CFrame = rootPart.CFrame + offset
            speedLine.Parent = workspace

            -- Animate speed lines
            local targetPosition = speedLine.Position - Vector3.new(0, 0, 30)
            local tweenInfo = TweenInfo.new(config.duration, Enum.EasingStyle.Linear)
            local moveTween = TweenService:Create(speedLine, tweenInfo, {
                CFrame = CFrame.new(targetPosition),
                Transparency = 1,
            })

            moveTween:Play()

            -- Cleanup
            Debris:AddItem(speedLine, config.duration + 0.1)
        end
    end
end

-- Play power-up activation effect
function EffectsController:PlayPowerUpEffect(position: Vector3, powerUpType: string)
    local config = EFFECT_CONFIGS.power_up

    -- Create power-up effect part
    local effectPart = self:CreateEffectPart("power_up", config)

    -- Set power-up specific color
    if powerUpType == "JETPACK" then
        effectPart.Color = Color3.fromRGB(255, 140, 0)
    elseif powerUpType == "SUPER_SNEAKERS" then
        effectPart.Color = Color3.fromRGB(0, 255, 0)
    elseif powerUpType == "COIN_MAGNET" then
        effectPart.Color = Color3.fromRGB(255, 0, 255)
    elseif powerUpType == "MULTIPLIER" then
        effectPart.Color = Color3.fromRGB(255, 255, 0)
    end

    effectPart.CFrame = CFrame.new(position)
    effectPart.Parent = workspace

    -- Pulsing effect
    local tweenInfo = TweenInfo.new(
        config.duration / 4,
        Enum.EasingStyle.Sine,
        Enum.EasingDirection.InOut,
        3, -- Repeat 3 times
        true -- Reverse
    )

    local pulseTween = TweenService:Create(effectPart, tweenInfo, {
        Size = effectPart.Size * 1.5,
        Transparency = 0.3,
    })

    pulseTween:Play()

    -- Final fade out
    pulseTween.Completed:Connect(function()
        local fadeInfo = TweenInfo.new(0.5, Enum.EasingStyle.Quad, Enum.EasingDirection.Out)
        local fadeTween = TweenService:Create(effectPart, fadeInfo, {
            Transparency = 1,
            Size = effectPart.Size * 0.1,
        })
        fadeTween:Play()

        -- Cleanup
        Debris:AddItem(effectPart, 0.6)
    end)
end

-- Play obstacle hit effect
function EffectsController:PlayObstacleHitEffect(position: Vector3)
    local effect = "explosion"
    local config = EFFECT_CONFIGS[effect]

    -- Create explosion effect
    local explosion = Instance.new("Part")
    explosion.Name = "ExplosionEffect"
    explosion.Size = config.size
    explosion.Color = config.color
    explosion.Material = config.material
    explosion.Anchored = true
    explosion.CanCollide = false
    explosion.Shape = Enum.PartType.Ball
    explosion.CFrame = CFrame.new(position)
    explosion.Transparency = 0.3
    explosion.Parent = workspace

    -- Explosion animation
    local tweenInfo = TweenInfo.new(config.duration, Enum.EasingStyle.Quad, Enum.EasingDirection.Out)
    local explosionTween = TweenService:Create(explosion, tweenInfo, {
        Size = config.size * config.scaleMultiplier,
        Transparency = 1,
    })

    explosionTween:Play()

    -- Cleanup
    Debris:AddItem(explosion, config.duration + 0.1)
end

-- Play coin magnet effect
function EffectsController:PlayCoinMagnetEffect(playerPosition: Vector3, coinPosition: Vector3)
    -- Create magnetic trail
    local trail = Instance.new("Part")
    trail.Name = "MagnetTrail"
    trail.Size = Vector3.new(0.2, 0.2, (playerPosition - coinPosition).Magnitude)
    trail.Color = Color3.fromRGB(255, 0, 255)
    trail.Material = Enum.Material.Neon
    trail.Anchored = true
    trail.CanCollide = false
    trail.Transparency = 0.5

    -- Position trail between player and coin
    local midPoint = (playerPosition + coinPosition) / 2
    trail.CFrame = CFrame.lookAt(midPoint, coinPosition)
    trail.Parent = workspace

    -- Animated trail
    local tweenInfo = TweenInfo.new(0.3, Enum.EasingStyle.Sine, Enum.EasingDirection.Out)
    local trailTween = TweenService:Create(trail, tweenInfo, {
        Size = Vector3.new(0.5, 0.5, trail.Size.Z),
        Transparency = 1,
    })

    trailTween:Play()

    -- Cleanup
    Debris:AddItem(trail, 0.4)
end

-- Update and cleanup active effects
function EffectsController:UpdateActiveEffects()
    local currentTime = tick()

    for i = #activeEffects, 1, -1 do
        local effect = activeEffects[i]

        -- Check if effect has expired
        if currentTime - effect.startTime > effect.duration + 1 then
            -- Force cleanup if still exists
            if effect.part and effect.part.Parent then
                effect.part:Destroy()
            end
            if effect.tween then
                effect.tween:Cancel()
            end
            if effect.connection then
                effect.connection:Disconnect()
            end

            table.remove(activeEffects, i)
        end
    end
end

-- Remove specific effect from active list
function EffectsController:RemoveActiveEffect(targetEffect: Effect)
    for i, effect in ipairs(activeEffects) do
        if effect == targetEffect then
            table.remove(activeEffects, i)
            break
        end
    end
end

-- Cleanup all effects
function EffectsController:Cleanup()
    -- Clean up active effects
    for _, effect in ipairs(activeEffects) do
        if effect.part then
            effect.part:Destroy()
        end
        if effect.tween then
            effect.tween:Cancel()
        end
        if effect.connection then
            effect.connection:Disconnect()
        end
    end

    table.clear(activeEffects)

    print("[EffectsController] Effects system cleaned up")
end

return EffectsController
]]></string>
          </Properties>
        </Item>
        <Item class="ModuleScript" referent="57">
          <Properties>
            <string name="Name">InputHandler</string>
            <string name="Source"><![CDATA[--!strict
-- InputHandler.lua - Enhanced input management for Subway Surfers
local GuiService = game:GetService("GuiService")
local UserInputService = game:GetService("UserInputService")

local InputHandler = {}

-- Types
export type InputCallback = (inputType: string, inputValue: any?) -> ()
export type TouchGesture = "swipeLeft" | "swipeRight" | "swipeUp" | "swipeDown" | "tap"

-- Private variables
local callbacks: { [string]: InputCallback } = {}
local touchStartPosition: Vector2?
local lastTouchTime = 0
local SWIPE_THRESHOLD = 50 -- Minimum distance for swipe
local TAP_TIME_THRESHOLD = 0.3 -- Maximum time for tap

-- Input mapping
local INPUT_MAPPINGS = {
    -- Movement
    [Enum.KeyCode.A] = "moveLeft",
    [Enum.KeyCode.Left] = "moveLeft",
    [Enum.KeyCode.D] = "moveRight",
    [Enum.KeyCode.Right] = "moveRight",

    -- Actions
    [Enum.KeyCode.W] = "jump",
    [Enum.KeyCode.Up] = "jump",
    [Enum.KeyCode.Space] = "jump",
    [Enum.KeyCode.S] = "slide",
    [Enum.KeyCode.Down] = "slide",

    -- Game control
    [Enum.KeyCode.R] = "startGame",
    [Enum.KeyCode.Escape] = "pauseGame",
    [Enum.KeyCode.P] = "pauseGame",
}

-- Register callback for input events
function InputHandler.RegisterCallback(inputType: string, callback: InputCallback)
    callbacks[inputType] = callback
    print("[InputHandler] Registered callback for:", inputType)
end

-- Fire callback if registered
local function fireCallback(inputType: string, inputValue: any?)
    local callback = callbacks[inputType]
    if callback then
        spawn(function()
            callback(inputType, inputValue)
        end)
    end
end

-- Handle keyboard input
local function handleKeyboardInput(input: InputObject, gameProcessed: boolean)
    if gameProcessed then
        return
    end

    local inputType = INPUT_MAPPINGS[input.KeyCode]
    if inputType then
        print("[InputHandler] Keyboard input:", input.KeyCode.Name, "->", inputType)
        fireCallback(inputType, nil)
    end
end

-- Detect touch gestures
local function detectTouchGesture(startPos: Vector2, endPos: Vector2, duration: number): TouchGesture?
    local deltaX = endPos.X - startPos.X
    local deltaY = endPos.Y - startPos.Y
    local distance = math.sqrt(deltaX ^ 2 + deltaY ^ 2)

    -- Check for tap (short duration, small movement)
    if duration <= TAP_TIME_THRESHOLD and distance < SWIPE_THRESHOLD then
        return "tap"
    end

    -- Check for swipe (sufficient distance)
    if distance >= SWIPE_THRESHOLD then
        local absDeltaX = math.abs(deltaX)
        local absDeltaY = math.abs(deltaY)

        -- Determine primary direction
        if absDeltaX > absDeltaY then
            if deltaX > 0 then
                return "swipeRight"
            else
                return "swipeLeft"
            end
        else
            if deltaY > 0 then
                return "swipeDown"
            else
                return "swipeUp"
            end
        end
    end

    return nil
end

-- Handle touch input
local function handleTouchInput(touch: InputObject, gameProcessed: boolean)
    if gameProcessed then
        return
    end

    local currentTime = tick()

    if touch.UserInputState == Enum.UserInputState.Begin then
        touchStartPosition = Vector2.new(touch.Position.X, touch.Position.Y)
        lastTouchTime = currentTime
    elseif touch.UserInputState == Enum.UserInputState.End and touchStartPosition then
        local duration = currentTime - lastTouchTime
        local endPos = Vector2.new(touch.Position.X, touch.Position.Y)
        local gesture = detectTouchGesture(touchStartPosition, endPos, duration)

        if gesture then
            print("[InputHandler] Touch gesture detected:", gesture)

            -- Map touch gestures to game actions
            if gesture == "swipeLeft" then
                fireCallback("moveLeft", nil)
            elseif gesture == "swipeRight" then
                fireCallback("moveRight", nil)
            elseif gesture == "swipeUp" then
                fireCallback("jump", nil)
            elseif gesture == "swipeDown" then
                fireCallback("slide", nil)
            elseif gesture == "tap" then
                fireCallback("jump", nil) -- Default tap action is jump
            end
        end

        touchStartPosition = nil
    end
end

-- Initialize input handling
function InputHandler.Initialize()
    print("[InputHandler] Initializing input system...")

    -- Keyboard input
    UserInputService.InputBegan:Connect(handleKeyboardInput)

    -- Touch input (mobile)
    UserInputService.TouchStarted:Connect(handleTouchInput)
    UserInputService.TouchEnded:Connect(handleTouchInput)

    -- Gamepad support (future enhancement)
    UserInputService.GamepadConnected:Connect(function(gamepad)
        print("[InputHandler] Gamepad connected:", gamepad)
    end)

    print("[InputHandler] Input system initialized!")
end

-- Get platform-specific controls info
function InputHandler.GetControlsInfo(): { string }
    local platform = GuiService:IsTenFootInterface() and "Console"
        or UserInputService.TouchEnabled and "Mobile"
        or "Desktop"

    if platform == "Mobile" then
        return {
            "Swipe left/right to change lanes",
            "Swipe up to jump",
            "Swipe down to slide",
            "Tap to jump",
        }
    elseif platform == "Console" then
        return {
            "Use D-Pad to move",
            "A to jump",
            "B to slide",
        }
    else -- Desktop
        return {
            "A/D or Arrow Keys to move",
            "W/Space to jump",
            "S to slide",
            "R to restart, Esc to pause",
        }
    end
end

-- Cleanup
function InputHandler.Destroy()
    callbacks = {}
    touchStartPosition = nil
    print("[InputHandler] Input system cleaned up")
end

return InputHandler
]]></string>
          </Properties>
        </Item>
      </Item>
      <Item class="Folder" referent="58">
        <Properties>
          <string name="Name">ui</string>
        </Properties>
        <Item class="ModuleScript" referent="59">
          <Properties>
            <string name="Name">UIController</string>
            <string name="Source"><![CDATA[--!nocheck
-- UIController.lua - Client-side UI management for Subway Surfers HUD
local UIController = {}

local Players = game:GetService("Players")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local TweenService = game:GetService("TweenService")
local UserInputService = game:GetService("UserInputService")

local player = Players.LocalPlayer
if not player then
    error("LocalPlayer not found")
end
local playerGui = player:WaitForChild("PlayerGui")

-- Import shared modules
local GameConfig = require(ReplicatedStorage:WaitForChild("Shared"):WaitForChild("GameConfig"))
local GameState = require(ReplicatedStorage:WaitForChild("Shared"):WaitForChild("GameState"))

-- UI Elements (will be created dynamically)
local hudFrame: Frame
local scoreLabel: TextLabel
local coinsLabel: TextLabel
local distanceLabel: TextLabel
local speedLabel: TextLabel
local powerUpFrame: Frame
local pauseButton: TextButton
local _mobileControlsFrame: Frame

-- Legacy UI for compatibility
UIController.MenuUI = nil
UIController.GameUI = nil
UIController.EndGameUI = nil
UIController.CurrentUI = nil
UIController.PlayerController = nil

-- State
local currentScore = 0
local currentCoins = 0
local currentDistance = 0
local currentSpeed = 0
local activePowerUps: { [string]: number } = {} -- powerUpType -> endTime
local isGameActive = false
local isPaused = false

-- Remote Events
local RemoteEvents = ReplicatedStorage:WaitForChild("RemoteEvents")
local PlayerActionEvent = RemoteEvents:WaitForChild("PlayerAction")
local GameStateChangedEvent = RemoteEvents:WaitForChild("GameStateChanged")
local ScoreUpdateEvent = RemoteEvents:WaitForChild("ScoreUpdate")
local PowerUpActivatedEvent = RemoteEvents:WaitForChild("PowerUpActivated")
local PowerUpDeactivatedEvent = RemoteEvents:WaitForChild("PowerUpDeactivated")

-- Initialize UI controller
function UIController:Initialize(playerController)
    self.PlayerController = playerController

    -- Create UI elements
    self:CreateMenuUI()
    self:CreateGameUI()
    self:CreateEndGameUI()

    -- Show menu by default
    self:ShowMenuUI()

    print("[UIController] UI Controller initialized")
end

-- Create main menu UI
function UIController:CreateMenuUI()
    local screenGui = Instance.new("ScreenGui")
    screenGui.Name = "MenuUI"
    screenGui.ResetOnSpawn = false
    screenGui.Parent = playerGui

    -- Background
    local background = Instance.new("Frame")
    background.Name = "Background"
    background.Size = UDim2.fromScale(1, 1)
    background.BackgroundColor3 = Color3.fromRGB(25, 25, 25)
    background.BorderSizePixel = 0
    background.Parent = screenGui

    -- Title
    local title = Instance.new("TextLabel")
    title.Name = "Title"
    title.Size = UDim2.fromScale(0.8, 0.2)
    title.Position = UDim2.fromScale(0.1, 0.1)
    title.BackgroundTransparency = 1
    title.Text = "ENDLESS RUNNER"
    title.TextColor3 = Color3.fromRGB(255, 255, 255)
    title.TextScaled = true
    title.Font = Enum.Font.GothamBold
    title.Parent = background

    -- Play Button
    local playButton = Instance.new("TextButton")
    playButton.Name = "PlayButton"
    playButton.Size = UDim2.fromScale(0.3, 0.1)
    playButton.Position = UDim2.fromScale(0.35, 0.45)
    playButton.BackgroundColor3 = Color3.fromRGB(0, 170, 0)
    playButton.BorderSizePixel = 0
    playButton.Text = "PLAY"
    playButton.TextColor3 = Color3.fromRGB(255, 255, 255)
    playButton.TextScaled = true
    playButton.Font = Enum.Font.GothamBold
    playButton.Parent = background

    -- Play button functionality
    playButton.MouseButton1Click:Connect(function()
        self.PlayerController:SendAction("StartGame")
    end)

    -- Stats Display
    local statsFrame = Instance.new("Frame")
    statsFrame.Name = "StatsFrame"
    statsFrame.Size = UDim2.fromScale(0.4, 0.3)
    statsFrame.Position = UDim2.fromScale(0.3, 0.6)
    statsFrame.BackgroundColor3 = Color3.fromRGB(40, 40, 40)
    statsFrame.BorderSizePixel = 0
    statsFrame.Parent = background

    local statsTitle = Instance.new("TextLabel")
    statsTitle.Name = "StatsTitle"
    statsTitle.Size = UDim2.fromScale(1, 0.3)
    statsTitle.Position = UDim2.fromScale(0, 0)
    statsTitle.BackgroundTransparency = 1
    statsTitle.Text = "YOUR STATS"
    statsTitle.TextColor3 = Color3.fromRGB(255, 255, 255)
    statsTitle.TextScaled = true
    statsTitle.Font = Enum.Font.Gotham
    statsTitle.Parent = statsFrame

    local highScoreLabel = Instance.new("TextLabel")
    highScoreLabel.Name = "HighScoreLabel"
    highScoreLabel.Size = UDim2.fromScale(1, 0.2)
    highScoreLabel.Position = UDim2.fromScale(0, 0.3)
    highScoreLabel.BackgroundTransparency = 1
    highScoreLabel.Text = "High Score: 0"
    highScoreLabel.TextColor3 = Color3.fromRGB(255, 255, 255)
    highScoreLabel.TextScaled = true
    highScoreLabel.Font = Enum.Font.Gotham
    highScoreLabel.Parent = statsFrame

    local coinsLabel = Instance.new("TextLabel")
    coinsLabel.Name = "CoinsLabel"
    coinsLabel.Size = UDim2.fromScale(1, 0.2)
    coinsLabel.Position = UDim2.fromScale(0, 0.5)
    coinsLabel.BackgroundTransparency = 1
    coinsLabel.Text = "Coins: 0"
    coinsLabel.TextColor3 = Color3.fromRGB(255, 255, 255)
    coinsLabel.TextScaled = true
    coinsLabel.Font = Enum.Font.Gotham
    coinsLabel.Parent = statsFrame

    local gamesPlayedLabel = Instance.new("TextLabel")
    gamesPlayedLabel.Name = "GamesPlayedLabel"
    gamesPlayedLabel.Size = UDim2.fromScale(1, 0.2)
    gamesPlayedLabel.Position = UDim2.fromScale(0, 0.7)
    gamesPlayedLabel.BackgroundTransparency = 1
    gamesPlayedLabel.Text = "Games Played: 0"
    gamesPlayedLabel.TextColor3 = Color3.fromRGB(255, 255, 255)
    gamesPlayedLabel.TextScaled = true
    gamesPlayedLabel.Font = Enum.Font.Gotham
    gamesPlayedLabel.Parent = statsFrame

    self.MenuUI = screenGui
end

-- Create game UI
function UIController:CreateGameUI()
    local screenGui = Instance.new("ScreenGui")
    screenGui.Name = "GameUI"
    screenGui.ResetOnSpawn = false
    screenGui.Enabled = false
    screenGui.Parent = playerGui

    -- Score Display
    local scoreFrame = Instance.new("Frame")
    scoreFrame.Name = "ScoreFrame"
    scoreFrame.Size = UDim2.fromScale(0.3, 0.1)
    scoreFrame.Position = UDim2.fromScale(0.05, 0.05)
    scoreFrame.BackgroundColor3 = Color3.fromRGB(0, 0, 0)
    scoreFrame.BackgroundTransparency = 0.5
    scoreFrame.BorderSizePixel = 0
    scoreFrame.Parent = screenGui

    local scoreLabel = Instance.new("TextLabel")
    scoreLabel.Name = "ScoreLabel"
    scoreLabel.Size = UDim2.fromScale(1, 1)
    scoreLabel.Position = UDim2.fromScale(0, 0)
    scoreLabel.BackgroundTransparency = 1
    scoreLabel.Text = "Score: 0"
    scoreLabel.TextColor3 = Color3.fromRGB(255, 255, 255)
    scoreLabel.TextScaled = true
    scoreLabel.Font = Enum.Font.GothamBold
    scoreLabel.Parent = scoreFrame

    -- Distance Display
    local distanceFrame = Instance.new("Frame")
    distanceFrame.Name = "DistanceFrame"
    distanceFrame.Size = UDim2.fromScale(0.3, 0.1)
    distanceFrame.Position = UDim2.fromScale(0.65, 0.05)
    distanceFrame.BackgroundColor3 = Color3.fromRGB(0, 0, 0)
    distanceFrame.BackgroundTransparency = 0.5
    distanceFrame.BorderSizePixel = 0
    distanceFrame.Parent = screenGui

    local distanceLabel = Instance.new("TextLabel")
    distanceLabel.Name = "DistanceLabel"
    distanceLabel.Size = UDim2.fromScale(1, 1)
    distanceLabel.Position = UDim2.fromScale(0, 0)
    distanceLabel.BackgroundTransparency = 1
    distanceLabel.Text = "Distance: 0m"
    distanceLabel.TextColor3 = Color3.fromRGB(255, 255, 255)
    distanceLabel.TextScaled = true
    distanceLabel.Font = Enum.Font.GothamBold
    distanceLabel.Parent = distanceFrame

    -- Pause Button
    local pauseButton = Instance.new("TextButton")
    pauseButton.Name = "PauseButton"
    pauseButton.Size = UDim2.fromScale(0.1, 0.1)
    pauseButton.Position = UDim2.fromScale(0.45, 0.05)
    pauseButton.BackgroundColor3 = Color3.fromRGB(100, 100, 100)
    pauseButton.BorderSizePixel = 0
    pauseButton.Text = "||"
    pauseButton.TextColor3 = Color3.fromRGB(255, 255, 255)
    pauseButton.TextScaled = true
    pauseButton.Font = Enum.Font.GothamBold
    pauseButton.Parent = screenGui

    pauseButton.MouseButton1Click:Connect(function()
        self.PlayerController:SendAction("PauseGame")
    end)

    self.GameUI = screenGui
end

-- Create end game UI
function UIController:CreateEndGameUI()
    local screenGui = Instance.new("ScreenGui")
    screenGui.Name = "EndGameUI"
    screenGui.ResetOnSpawn = false
    screenGui.Enabled = false
    screenGui.Parent = playerGui

    -- Background
    local background = Instance.new("Frame")
    background.Name = "Background"
    background.Size = UDim2.fromScale(1, 1)
    background.BackgroundColor3 = Color3.fromRGB(0, 0, 0)
    background.BackgroundTransparency = 0.3
    background.BorderSizePixel = 0
    background.Parent = screenGui

    -- Results Panel
    local resultsPanel = Instance.new("Frame")
    resultsPanel.Name = "ResultsPanel"
    resultsPanel.Size = UDim2.fromScale(0.6, 0.7)
    resultsPanel.Position = UDim2.fromScale(0.2, 0.15)
    resultsPanel.BackgroundColor3 = Color3.fromRGB(40, 40, 40)
    resultsPanel.BorderSizePixel = 0
    resultsPanel.Parent = background

    -- Game Over Title
    local gameOverTitle = Instance.new("TextLabel")
    gameOverTitle.Name = "GameOverTitle"
    gameOverTitle.Size = UDim2.fromScale(1, 0.2)
    gameOverTitle.Position = UDim2.fromScale(0, 0)
    gameOverTitle.BackgroundTransparency = 1
    gameOverTitle.Text = "GAME OVER"
    gameOverTitle.TextColor3 = Color3.fromRGB(255, 100, 100)
    gameOverTitle.TextScaled = true
    gameOverTitle.Font = Enum.Font.GothamBold
    gameOverTitle.Parent = resultsPanel

    -- Final Score
    local finalScoreLabel = Instance.new("TextLabel")
    finalScoreLabel.Name = "FinalScoreLabel"
    finalScoreLabel.Size = UDim2.fromScale(1, 0.15)
    finalScoreLabel.Position = UDim2.fromScale(0, 0.25)
    finalScoreLabel.BackgroundTransparency = 1
    finalScoreLabel.Text = "Final Score: 0"
    finalScoreLabel.TextColor3 = Color3.fromRGB(255, 255, 255)
    finalScoreLabel.TextScaled = true
    finalScoreLabel.Font = Enum.Font.Gotham
    finalScoreLabel.Parent = resultsPanel

    -- Play Again Button
    local playAgainButton = Instance.new("TextButton")
    playAgainButton.Name = "PlayAgainButton"
    playAgainButton.Size = UDim2.fromScale(0.4, 0.12)
    playAgainButton.Position = UDim2.fromScale(0.1, 0.75)
    playAgainButton.BackgroundColor3 = Color3.fromRGB(0, 170, 0)
    playAgainButton.BorderSizePixel = 0
    playAgainButton.Text = "PLAY AGAIN"
    playAgainButton.TextColor3 = Color3.fromRGB(255, 255, 255)
    playAgainButton.TextScaled = true
    playAgainButton.Font = Enum.Font.GothamBold
    playAgainButton.Parent = resultsPanel

    playAgainButton.MouseButton1Click:Connect(function()
        self.PlayerController:SendAction("StartGame")
    end)

    -- Menu Button
    local menuButton = Instance.new("TextButton")
    menuButton.Name = "MenuButton"
    menuButton.Size = UDim2.fromScale(0.4, 0.12)
    menuButton.Position = UDim2.fromScale(0.5, 0.75)
    menuButton.BackgroundColor3 = Color3.fromRGB(100, 100, 100)
    menuButton.BorderSizePixel = 0
    menuButton.Text = "MENU"
    menuButton.TextColor3 = Color3.fromRGB(255, 255, 255)
    menuButton.TextScaled = true
    menuButton.Font = Enum.Font.GothamBold
    menuButton.Parent = resultsPanel

    menuButton.MouseButton1Click:Connect(function()
        self:ShowMenuUI()
    end)

    self.EndGameUI = screenGui
end

-- Show menu UI
function UIController:ShowMenuUI(menuData)
    self:HideAllUI()
    if self.MenuUI then
        self.MenuUI.Enabled = true
        self.CurrentUI = self.MenuUI

        -- Update stats if data provided
        if menuData then
            self:UpdateMenuStats(menuData)
        end
    end
end

-- Show game UI
function UIController:ShowGameUI()
    self:HideAllUI()
    if self.GameUI then
        self.GameUI.Enabled = true
        self.CurrentUI = self.GameUI
    end
end

-- Show end game UI
function UIController:ShowEndGameUI(endData)
    self:HideAllUI()
    if self.EndGameUI then
        self.EndGameUI.Enabled = true
        self.CurrentUI = self.EndGameUI

        -- Update final score
        if endData and endData.finalScore then
            local finalScoreLabel = self.EndGameUI.Background.ResultsPanel.FinalScoreLabel
            finalScoreLabel.Text = "Final Score: " .. endData.finalScore
        end
    end
end

-- Hide all UI
function UIController:HideAllUI()
    if self.MenuUI then
        self.MenuUI.Enabled = false
    end
    if self.GameUI then
        self.GameUI.Enabled = false
    end
    if self.EndGameUI then
        self.EndGameUI.Enabled = false
    end
    self.CurrentUI = nil
end

-- Update game state
function UIController:UpdateGameState(gameState, data)
    -- Handle UI transitions based on game state
    if gameState == GameState.States.MENU then
        self:ShowMenuUI(data)
    elseif gameState == GameState.States.PLAYING then
        self:ShowGameUI()
    elseif gameState == GameState.States.GAME_OVER then
        self:ShowEndGameUI(data)
    end
end

-- Update score display
function UIController:UpdateScore(totalScore, scoreGained)
    if self.GameUI and self.GameUI.Enabled then
        local scoreLabel = self.GameUI.ScoreFrame.ScoreLabel
        scoreLabel.Text = "Score: " .. totalScore

        -- Animate score gain if provided
        if scoreGained and scoreGained > 0 then
            self:AnimateScoreGain(scoreGained)
        end
    end
end

-- Animate score gain effect
function UIController:AnimateScoreGain(scoreGained)
    -- Create floating score text
    local floatingScore = Instance.new("TextLabel")
    floatingScore.Size = UDim2.fromScale(0.2, 0.1)
    floatingScore.Position = UDim2.fromScale(0.4, 0.3)
    floatingScore.BackgroundTransparency = 1
    floatingScore.Text = "+" .. scoreGained
    floatingScore.TextColor3 = Color3.fromRGB(255, 255, 0)
    floatingScore.TextScaled = true
    floatingScore.Font = Enum.Font.GothamBold
    floatingScore.Parent = self.GameUI

    -- Animate floating effect
    local tweenInfo = TweenInfo.new(1, Enum.EasingStyle.Quad, Enum.EasingDirection.Out)
    local tween = TweenService:Create(floatingScore, tweenInfo, {
        Position = UDim2.fromScale(0.4, 0.1),
        TextTransparency = 1,
    })
    tween:Play()

    -- Clean up after animation
    tween.Completed:Connect(function()
        floatingScore:Destroy()
    end)
end

-- Update menu stats
function UIController:UpdateMenuStats(playerData)
    if not self.MenuUI or not playerData then
        return
    end

    local statsFrame = self.MenuUI.Background.StatsFrame
    statsFrame.HighScoreLabel.Text = "High Score: " .. (playerData.highScore or 0)
    statsFrame.CoinsLabel.Text = "Coins: " .. (playerData.coins or 0)
    statsFrame.GamesPlayedLabel.Text = "Games Played: " .. (playerData.gamesPlayed or 0)
end

-- Show collectible effect
function UIController:ShowCollectibleEffect(collectibleType, value)
    -- Visual feedback for collecting items
    -- This could include particle effects, sound, etc.
    print("[UIController] Collected:", collectibleType, "Value:", value)
end

-- Show damage effect
function UIController:ShowDamageEffect()
    -- Visual feedback for taking damage
    if not self.GameUI then
        return
    end

    -- Flash red overlay
    local damageOverlay = Instance.new("Frame")
    damageOverlay.Size = UDim2.fromScale(1, 1)
    damageOverlay.Position = UDim2.fromScale(0, 0)
    damageOverlay.BackgroundColor3 = Color3.fromRGB(255, 0, 0)
    damageOverlay.BackgroundTransparency = 0.7
    damageOverlay.BorderSizePixel = 0
    damageOverlay.Parent = self.GameUI

    -- Fade out
    local tweenInfo = TweenInfo.new(0.5, Enum.EasingStyle.Quad, Enum.EasingDirection.Out)
    local tween = TweenService:Create(damageOverlay, tweenInfo, { BackgroundTransparency = 1 })
    tween:Play()

    tween.Completed:Connect(function()
        damageOverlay:Destroy()
    end)
end

return UIController
]]></string>
          </Properties>
        </Item>
      </Item>
    </Item>
  </Item>
  <Item class="Workspace" referent="60">
    <Properties>
      <string name="Name">Workspace</string>
    </Properties>
  </Item>
</roblox>